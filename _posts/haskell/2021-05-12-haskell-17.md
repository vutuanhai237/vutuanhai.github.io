---
layout: post
title: "Haskell #17: Monad (kế)"
categories: haskell
link: https://vutuanhai237.github.io/haskell/2021/05/11/haskell-17.html
---

[Haskell #17: Monad](https://vutuanhai237.github.io/haskell/2021/05/10/haskell-17.html)

Trong phần này, ta sẽ tìm hiểu thêm một số Monad nữa. Việc khám phá các Monad sẽ củng cố trực giác của ta về Monad.

#### **17.7. Writer**

Monad Writer dành cho những giá trị có giá trị khác gắn vào và đóng vai trò như một dạng giá trị để ghi chép. Writer cho phép ta thực hiện tính toán trong khi vẫn yên tâm rằng các giá trị ghi chép lại đã được kết hợp làm một và giá trị này sau đó được gắn vào với kết quả.

Chẳng hạn, ta có thể muốn trang bị cho các giá trị hiện có thêm các chuỗi kí tự giải thích xem điều gì đang diễn ra, đặc biệt là đối với debug. Xét một hàm nhận vào một số tên cướp trong băng đảng và báo cho ta biết xem băng cướp đó có lớn hay không.
```
isBigGang :: Int -> Bool
isBigGang x = x > 9
```
Bây giờ, thay vì kết quả là True hoặc False, ta muốn hàm này trả về một chuỗi:
```
isBigGang :: Int -> (Bool, String)
isBigGang x = (x > 9, "Compared gang size to 9.")
```
Như vậy bây giờ, thay vì chỉ trả về Bool, ta trả về một tuple trong đó phần tử thứ nhất là giá trị thực còn phần tử thứ hai là chuỗi đi kèm giá trị đó. `isBigGang` nhận một giá trị thường rồi trả về một giá trị kèm ngữ cảnh. Như đã thấy, việc đưa một giá trị vào hàm không thành vấn đề. Bây giờ sẽ thế nào nếu ta đã có một giá trị kèm theo chuỗi ghi chép gắn với nó, như (3, "Smallish gang."), và ta muốn đưa nó vào trong hàm isBigGang? Dường như một lần nữa, ta phải đối diện với câu hỏi: nếu đã có một hàm vốn nhận giá trị và trả về giá trị kèm ngữ cảnh, làm thế nào để ta lấy giá trị kèm ngữ cảnh và đưa nó vào trong hàm này?

Khi khám phá Maybe, ta đã tạo `applyMaybe`, nhận một `Maybe a` và hàm $f$ kiểu `a -> Maybe b`. `applyMaybe` lấy giá trị trong ngữ cảnh đi kèm và đưa vào $f$. Bên trong $f$, ta có quyền coi `a` là giá trị thông thường, vì `applyMaybe` (hay `>>=`) đã đảm nhiệm việc kiểm tra `Maybe a` là `Nothing` hoặc `Just`.

Cũng theo tinh thần này, ta tạo một hàm nhận vào một giá trị với ghi chép gắn kèm, kiểu `(a, String)` và hàm $f$ kiểu `a -> (b, String)` rồi đưa giá trị đó vào hàm. Ta sẽ gọi nó là `applyLog`. 
```
applyLog :: (a, String) -> (a -> (b, String)) -> (b, String)
applyLog (x, log) f = let (y, newLog) = f x in (y, log ++ newLog)
```
Khi có giá trị $x$ với ngữ cảnh $log$, và muốn đưa nó vào hàm $f$, ta sẽ cố gắng tách $x$ ra rồi ánh xạ $f$ lên $x$. Ta nhận được pair `(y, newLog)`, trong đó `y` là kết quả mới và `newLog` là nội dung ghi chép mới. `++` sẽ được sử dụng để bổ sung nội dung ghi chép mới vào ghi chép cũ.
```
ghci> (3, "Smallish gang.") `applyLog` isBigGang
(False,"Smallish gang.Compared gang size to 9")
ghci> (30, "A freaking platoon.") `applyLog` isBigGang
(True,"A freaking platoon.Compared gang size to 9")
```
Sau đây là một số ví dụ nữa về cách dùng applyLog:
```
ghci> ("Tobin","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))
(5,"Got outlaw name.Applied length.")
ghci> ("Bathcat","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length"))
(7,"Got outlaw name.Applied length")
```
#### **17.8. Kết hợp Monoid**

`applyLog` nhận các giá trị kiểu `(a, String)` nhưng chúng ta còn có thể mở rộng kiểu dữ liệu phần log:
```
applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c])
```
Bây giờ, log là list và kiểu của các log phải giống nhau để chúng ta có thể sử dụng hàm `++` giữa chúng.

Chúng ta mở rộng thêm một cấp nữa khi xác định rằng log có thể là kiểu dữ liệu bất kỳ mà là Monoid. Việc này giúp chúng ta trừu tượng hóa hàm `++`, việc nối các log với nhau sẽ được thực thi bằng hàm `mappend`.
```
applyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)
applyLog (x, log) f = let (y, newLog) = f x in (y,log `mappend` newLog)
```
Chẳng hạn, ta có thể có một tuple trong đó chứa tên món hàng và giá bán tương ứng, là Monoid. Ta chỉ việc dùng newtype là Sum để đảm bảo chắc chắn rằng giá sẽ được cộng thêm vào khi chọn các món hàng khác nhau.
```
import Data.Monoid

type Food = String
type Price = Sum Int

addDrink :: Food -> (Food, Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)
```
Hãy nhớ lại rằng, việc dùng `mappend` với `Sum` sẽ trả về kết quả là những giá trị được gói lại:
```
ghci> Sum 3 `mappend` Sum 9
Sum {getSum = 12}
```
```
ghci> ("beans", Sum 10) `applyLog` addDrink
("milk", Sum {getSum = 35})
ghci> ("jerky", Sum 25) `applyLog` addDrink
("whiskey", Sum {getSum = 124})
ghci> ("dogmeat", Sum 5) `applyLog` addDrink
("beer", Sum {getSum = 35})
```
```
ghci> ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink
("beer",Sum {getSum = 65})
```
Việc thêm đồ uống kèm theo món thịt chó trả về `("beer", Sum 35)`. Và nếu ta dùng `applyLog` để đưa kết quả này vào `addDrink`, ta thu được bia khác và lần này kết quả là `("beer", Sum 65)`.

#### **17.9. Kiểu Writer**

Một giá trị kết hợp với một Monoid có thể là Monad, và kiểu dữ liệu này được gói trong Module Control.Monad.Writer. Định nghĩa của nó rất đơn giản:
```
newtype Writer w a = Writer { runWriter :: (a, w) }
```
Nó được gói trong một newtype do vậy nó được phân biệt so với tuple. Tham số `a` biểu diễn cho kiểu của giá trị còn tham số `w` biểu diễn cho kiểu của Monoid kèm theo.

Monad Writer được định nghĩa như sau:
```
instance (Monoid w) => Monad (Writer w) where
    return x = Writer (x, mempty)
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
```
`>>=` rất giống với hàm `applyLog` ta đã gặp trước đây, chỉ khác là khi sử dụng newtype `Writer`, ta phải gỡ gói, lấy giá trị $x$ rồi áp dụng hàm $f$ lên nó. Quá trình này trả về một `Writer w a`. Ta gọi $y$ là kết quả mới và dùng `mappend` để kết hợp Monoid cũ và mới. Ta ghép hai thứ lại với nhau bằng constructor Writer để cho kết quả là Writer thay vì đơn thuần là tuple.

`return` nhận một giá trị rồi đặt giá trị này vào ngữ cảnh tối thiểu, ngữ cảnh ở đây là giá trị Monoid càng ít ảnh hưởng đến các giá trị Monoid khác càng tốt nên `mempty` được sử dụng. Khi dùng `return` để tạo một Writer $w$ rồi dùng `>>=` để đưa $w$ vào hàm thì giá trị Monoid trả về chỉ là thứ mà hàm trả về. 
```haskell
ghci> runWriter (return 3 :: Writer String Int)
(3,"")
ghci> runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci> runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
```
*runWriter là hàm chuyển Writer sang tuple, để có thể hiển thị được.*

Thực thể Writer không bao gồm cách tạo lập fail, vì vậy nếu có mẫu cần khớp bị thất bại trong khối lệnh do, thì error sẽ được gọi đến.

DÙNG KHỐI LỆNH “DO” VỚI WRITER
Bây giờ khi đã có thực thể Monad, ta có thể tự nhiên dùng khối lệnh do cho các giá trị Writer. Sẽ rất tiện trong trường hợp ta có một số giá trị Writer và muốn thao tác chúng. Cũng như với các Monad khác, ta có thể coi chúng như những giá trị thường và ngữ cảnh sẽ tự lo cho ta. Trong trường hợp này, tất cả những giá trị Monoid đi kèm theo đều được mappend và do đó được phản ánh trong kết quả cuối cùng. Sau đây là một ví dụ đơn giản của việc sử dụng khối lệnh do với Writer để nhân hai số:

import Control.Monad.Writer

logNumber :: Int -> Writer [String] Int
logNumber x = Writer (x, ["Got number: " ++ show x])

multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    return (a*b)
logNumber nhận một con số rồi tạo nên một giá trị Writer từ nó. Đối với Monoid, ta dùng một list các chuỗi và ta trang bị con số với một chuỗi đơn phần tử chỉ để báo rằng ta có con số như vậy. multWithLog là một giá trị Writer mà nhân 3 với 5 rồi đảm bảo rằng những ghi chép kèm theo hai con số này được bao gồm trong ghi chép cuối cùng. Ta dùng return để biểu thị kết quả a*b. Vì return chỉ nhận thứ gì đó rồi đặt nó vào trong ngữ cảnh tối thiểu, nên ta có thể chắc rằng nó không cộng gì thêm vào bản ghi chép. Sau đây là thứ mà ta thấy được khi chạy mã lệnh này:

ghci> runWriter multWithLog
(15,["Got number: 3","Got number: 5"])
Đôi khi ta chỉ muốn giá trị Monoid nào đó được kèm theo tại một điểm nhất định. Với mục đích này, hàm tell sẽ hữu dụng. Nó thuộc về lớp MonadWriter và trong trường hợp Writer nó nhận một giá trị Monoid, như ["This is going on"] và tạo ra một giá trị Writer để biểu diễn cho giá trị đại diện () đóng vai trò kết quả, nhưng lại có giá trị Monoid gắn kèm theo. Khi ta có một giá trị Monad mang kết quả (), ta không gắn nó vào một biến. Sau đây là multWithLog nhưng có kèm theo báo cáo phụ thêm:

multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    tell ["Gonna multiply these two"]
    return (a*b)
Điều quan trọng là để return (a*b) ở dòng dưới cùng, vì kết quả của dòng lệnh cuối trong khối lệnh do là kết quả của toàn bộ biểu thức do này. Nếu ta đưa tell xuống cuối trong trường hợp này, thì () sẽ là kết quả của biểu thức do. Như vậy ta mất đi kết quả của phép nhân. Tuy nhiên khi đó nội dung ghi chép vẫn như vậy. Sau đây là kết quả khi chạy mã lệnh trên:

ghci> runWriter multWithLog
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])
BỔ SUNG GHI CHÉP VÀO TRONG CHƯƠNG TRÌNH
Thuật toán Euclid nhận vào hai con số rồi tìm ước số chung lớn nhất của chúng; nghĩa là số lớn nhất mà hai số ban đầu cùng chia hết. Haskell đã có sẵn hàm gcd, thực hiện chính xác việc này, nhưng ta hãy tự tay viết hàm đồng thời trang bị cho nó khả năng ghi chép. Sau đây là thuật toán thông thường:

gcd' :: Int -> Int -> Int
gcd' a b 
    | b == 0    = a
    | otherwise = gcd' b (a `mod` b)
Thuật toán này rất đơn giản. Ban đầu, nó kiểm tra xem liệu số thứ hai có bằng 0 hay không. Nếu đúng, kết quả sẽ là số thứ nhất. Nếu không, thì kết quả sẽ là ước số chung lớn nhất của số thứ hai và số dư của phép chia số thứ nhất cho số thứ hai. Chẳng hạn, nếu muốn biết ước số chung lớn nhất giữa 8 và 3 là gì, ta chỉ việc theo thuật toán đã phác thảo ở trên. Vì 3 khác 0, nên ta phải đi tìm ước số chung lớn nhất giữa 3 và 2 (nếu ta chia 8 cho 3 thì số dư sẽ là 2). Tiếp theo, ta tính ước số chung lớn nhất giữa 3 và 2. Vì 2 vẫn chưa bằng 0, nên bây giờ ta có 2 và 1. Số thứ hai chưa bằng 0 nên ta lại thực hiện thuật toán với 1 và 0, vì 2 chia 1 dư 0. Và cuối cùng, khi bây giờ số thứ hai đã bằng 0 rồi, thì kết quả cuối cùng là 1. Ta hãy xem liệu mã lệnh chạy ra có cho kết quả giống như vậy:

ghci> gcd' 8 3
1
Đúng. Rất tốt! Bây giờ, ta muốn trang bị cho kết quả của ta một ngữ cảnh, và ngữ cảnh này là một giá trị Monoid đóng vai trò như bản ghi chép. Cũng giống như trước đây, ta sẽ dùng list những chuỗi kí tự làm Monoid. Khi đó kiểu của hàm gcd' mới sẽ là:

gcd' :: Int -> Int -> Writer [String] Int
Việc còn lại là trang bị cho hàm này những giá trị ghi chép. Sau đây là mã lệnh:

import Control.Monad.Writer

gcd' :: Int -> Int -> Writer [String] Int
gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)
Hàm này nhận hai giá trị Int bình thường rồi trả về một Writer [String] Int, nghĩa là một Int kèm theo một ngữ cảnh ghi chép. Trong trường hợp b bằng 0, thay vì việc chỉ đưa kết quả là a, ta dùng một biểu thức do để kết hợp một giá trị Writer làm kết quả. Đầu tiên, ta dùng tell để báo rằng ta đã xong và rồi dùng return để biểu diễn a là kết quả của khối lệnh do. Thay vì biểu thức do này, ta cũng có thể viết như sau:

Writer (a, ["Finished with " ++ show a])
Tuy vậy, tôi nghĩ rằng biểu thức do thì dễ đọc hơn. Tiếp theo, ta có tình huống khi b khác 0. Trong trường hợp nay, ta ghi lại rằng ta dùng mod để tính ra số dư trong phép chia của a cho b. Sau đó, dòng lệnh thứ hai trong biểu thức do chỉ việc gọi gcd' một cách đệ quy. Hãy nhớ rằng, bây giờ gcd' cuối cùng đã trả về một giá trị Writer, nên hoàn toàn đúng khi viết dòng lệnh gcd' b (a `mod` b) bên trong một biểu thức do.

Nếu như tự tay dò theo việc thực thi của hàm mới gcd' này để xem các ghi chép được bổ sung thế nào là một điều có ích, thì tôi nghĩ rằng sâu xa hơn, ta nên nhìn vào bức tranh tổng thể và coi những ghi chép này là các giá trị với một ngữ cảnh, rồi từ đó hiểu thêm là kết quả cuối cùng sẽ ra sao.

Ta hãy thử với hàm gcd' mới. Kết quả của nó là một giá trị Writer [String] Int và nếu ta tháo gỡ giá trị đó khỏi newtype của nó, ta sẽ thu được một bộ dữ liệu. Phần thứ nhất của bộ là kết quả. Ta hãy xem liệu có ổn không:

ghci> fst $ runWriter (gcd' 8 3)
1
Tốt! Thế còn phần ghi chép? Vì nội dung ghi chép là một list các chuỗi kí tự, nên ta hãy dùng mapM_ putStrLn để in chúng ra màn hình:

ghci> mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
Tôi nghĩ rằng thật tuyệt vời khi ta có thể sửa đổi thuật toán thông dụng thành một thuật toán có khả năng báo cáo quá trình hoạt động của nó, chỉ bằng cách thay đổi những giá trị thường thành giá trị Monad và để cho >>= của Writer đảm nhiệm nội dung ghi chép cho ta. Có thể thêm cơ chế ghi chép gần như cho hàm nào cũng được. Ta chỉ việc thay thể các giá trị thông thường bằng những giá trị Writer khi cần và thay cách áp dụng hàm thông thường bằng >>= (hoặc các biểu thức do nếu cách này dễ đọc hơn).

CÁCH KHÔNG HIỆU QUẢ ĐỂ TẠO DỰNG list
Khi dùng Monad Writer, bạn phải cẩn thận trong việc dùng Monoid nào, vì việc dùng list đôi khi có thể trở nên rất chậm chạp. Đó là bởi list dùng đến ++ để mappend, mà việc dùng ++ để bổ sung phần tử vào phía cuối list sẽ chậm nếu list rất dài.

Trong hàm gcd', việc ghi chép được thực hiện rất nhanh vì cách bổ sung list rút cục sẽ như sau:

a ++ (b ++ (c ++ (d ++ (e ++ f))))
Danh sách là loại cấu trúc dữ liệu được tạo dựng từ trái sang phải, và cách làm trên là hiệu quả, vì ban đầu ta hoàn thành việc tạo dựng phần bên trái của list rồi sau đó mới bổ sung một list dài hơn từ bên phía phải. Nhưng nếu ta không cẩn thận, việc dùng Monad Writer có thể sẽ tạo ra phép bổ sung list trông như sau:

((((a ++ b) ++ c) ++ d) ++ e) ++ f
Cách tính toán này kết hợp về bên phía trái thay vì về phía phải. Đây là cách không hiệu quả vfi mỗi lần muốn nối phần bên phải vào phần bên trái, thì phần bên trái list lại phải được tạo dựng từ đầu!

Hàm sau đây hoạt động giống như gcd', chỉ khác là nó ghi chép các thứ theo chiều đảo ngược. Trước hết, nó tạo ra ghi chép cho phần còn lại của thủ tục rồi bổ sung vào cuối bản ghi chép.

import Control.Monad.Writer

gcdReverse :: Int -> Int -> Writer [String] Int
gcdReverse a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result <- gcdReverse b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result
Trước hết, việc đệ quy được thực hiện, và giá trị kết quả được gắn với result. Tiếp theo là bổ sung bước hiện hành vào bản ghi, nhưng bước hiện hành sẽ đưa vào cuối ghi chép tạo bởi đệ quy. Sau cùng, kết quả của đệ quy được hiển thị như là kết quả cuối cùng. Sau đây là hoạt động của hàm mới viết:

ghci> mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
Nó rất kém hiệu quả vì kết cục là phải dùng ++ theo hướng kết hợp trái thay vì kết hợp phải.

DANH SÁCH HIỆU
cactuses

Vì đôi lúc list có thể kém hiệu quả khi được liên tiếp bổ sung theo cách nói trước, nên tốt nhất là ta dùng một cấu trúc dữ liệu luôn cho phép bổ sung một cách hiệu quả. Một cấu trúc dữ liệu như vậy là list hiệu. Một list hiệu cũng giống như list, chỉ hơn ở chỗ nó là một hàm nhận một list rồi gắn liền một list khác về phía trước nó. Tương ứng với một dánh sách như [1,2,3], list hiệu sẽ là hàm \xs -> [1,2,3] ++ xs. Một list rỗng thông thường là [], còn list hiệu rỗng sẽ là hàm \xs -> [] ++ xs.

Điều hay ở list hiệu là ở chỗ chúng cho phép bổ sung một cách hiệu quả. Khi ta bổ sung hai list thông thường với ++, máy sẽ phải thực hiện duyệt từ đầu đến cuối của list bên trái dấu ++ rồi mới gắn list còn lại tiếp vào đó. Nhưng sẽ ra sao nếu ta thực hiện cách list hiệu rồi biểu diễn các list được xét dưới dạng các hàm? À, khi đó việc kết nối hai list hiệu sẽ được thực hiện như sau:

f `append` g = \xs -> f (g xs)
Hãy nhớ rằng, f và g là những hàm nhận các list và rồi chèn thêm nội dung nào đó vào trước những list này. Chẳng hạn, nếu f là hàm ("dog"++) (chỉ là một cách viết khác cho \xs -> "dog" ++ xs) và g là hàm ("meat"++), thì f `append` g tạo nên một hàm mới tương đương với hàm sau đây:

\xs -> "dog" ++ ("meat" ++ xs)
Ta đã nối liền hai list hiệu với nhau, đơn giản chỉ bằng cách tạo một hàm mới để áp dụng một list hiệu với một list nào đó, tiếp đến là list còn lại.

Ta hãy tạo một vỏ bọc newtype cho list hiệu, để có thể dễ dàng chuyển những thực thể Monoid đến những list này:

newtype Diff list a = Diff list { getDiff list :: [a] -> [a] }
Kiểu dữ liệu mà ta bọc là [a] -> [a] vì một list hiệu chỉ đơn giản là một hàm nhận vào một list rồi trả về một list khác. Thật dễ chuyển đổi qua lại giữa list thông thường và list hiệu:

toDiff list :: [a] -> Diff list a
toDiff list xs = Diff list (xs++)

fromDiff list :: Diff list a -> [a]
fromDiff list (Diff list f) = f []
Để biến một list thường thanh list hiệu, ta chỉ cần thực hiện việc mà ta đã làm trước đây rồi biến nó thành hàm để đặt list lên đầu của list khác.Vì một list hiệu là một hàm để đặt một thứ nào đó lên phía đầu của một list khác, nên nếu ta muốn thứ nêu trên, thì cần phải áp dụng hàm đối với một list rỗng!

Sau đây là thực thể Monoid:

instance Monoid (Diff list a) where
    mempty = Diff list (\xs -> [] ++ xs)
    (Diff list f) `mappend` (Diff list g) = Diff list (\xs -> f (g xs))
Lưu ý rằng đối với list, mempty đơn giản là hàm id còn mappend thực ra chính là phép hàm hợp. Ta hãy xem nó hoạt động ra sao:

ghci> fromDiff list (toDiff list [1,2,3,4] `mappend` toDiff list [1,2,3])
[1,2,3,4,1,2,3]
Đỉnh thật! Bây giờ ta có thể tăng hiệu quả của hàm gcdReverse vừa viết bằng cách dùng list hiệu thay vì list thường:

import Control.Monad.Writer

gcd' :: Int -> Int -> Writer (Diff list String) Int
gcd' a b
    | b == 0 = do
        tell (toDiff list ["Finished with " ++ show a])
        return a
    | otherwise = do
        result <- gcd' b (a `mod` b)
        tell (toDiff list [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result
Ta chỉ phải thay đổi kiểu của Monoid từ [String] sang thành Diff list String rồi sau đó khi dùng tell, thì chuyển đổi list thường thành list hiệu bằng toDiff list. Hãy xem liệu bản ghi chép có được hợp lại trọn vẹn hay không:

ghci> mapM_ putStrLn . fromDiff list . snd . runWriter $ gcdReverse 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8
Ta viết gcdReverse 110 34, sau đó dùng runWriter để tháo gỡ nó khỏi newtype, rồi áp dụng snd cho kết quả chỉ để lấy nội dung ghi chép, tiếp theo áp dụng fromDiff list để chuyển đổi nó thành một list thông thường và cuối cùng là in toàn bộ ra màn hình.

SO SÁNH HIỆU NĂNG
Để hình dung được list hiệu giúp nâng cao hiệu năng chạy chương trình thêm bao nhiêu, ta hãy xét hàm sau, chỉ đơn thuần là đếm ngược từ một số về 0, nhưng tạo ra bản ghi theo chiều ngược lại, giống như gcdReverse, như vậy các con số trong nội dung ghi chép sẽ được đếm tăng dần:

finalCountDown :: Int -> Writer (Diff list String) ()
finalCountDown 0 = do
    tell (toDiff list ["0"])
finalCountDown x = do
    finalCountDown (x-1)
    tell (toDiff list [show x])
Nếu ta đưa vào hàm này số 0, thì nó sẽ ghi lại chính số đó. Với bất kì số nào khác, ban đầu nó sẽ đếm các số trước, từ 0 và bổ sung những số đó vào nội dung ghi chép. Vì vậy, nếu ta áp dụng finalCountDown đối với 100, thì chuỗi "100" sẽ đứng cuối cùng trong nội dung ghi chép.

Dù sao, nếu bạn tải hàm này trong GHCi rồi áp dụng nó cho một số lớn, như 500000, bạn sẽ thấy nó nhanh chóng đếm từ 0 trở lên:

ghci> mapM_ putStrLn . fromDiff list . snd . runWriter $ finalCountDown 500000
0
1
2
...
Tuy nhiên, nếu bạn thay list hiệu bằng list thường, như sau:

finalCountDown :: Int -> Writer [String] ()
finalCountDown 0 = do
    tell ["0"]
finalCountDown x = do
    finalCountDown (x-1)
    tell [show x]
Rồi bảo GHCi bắt đầu đếm:

ghci> mapM_ putStrLn . snd . runWriter $ finalCountDown 500000
Thì bạn sẽ thấy rằng việc đếm thực sự rất chậm.

Dĩ nhiên, đây không phải là cách đúng đắn và khoa học để kiểm tra xem chương trình đang xét chạy nhanh bao nhiêu, nhưng qua ví dụ này, ta có thể thấy được rằng việc dùng list hiệu bắt đầu cho ra kết quả tức khắc, còn list thường sẽ quá lâu.

Ồ, mà bây giờ thì bài hát Final Countdown do ban nhạc Europe trình diễn đã để lại dấu ấn trong tâm trí bạn rồi!


Reader? Hừ, đùng đùa thế nữa!
bang youre dead

Trong chương nói về các áp dụng (applicative), ta đã thấy rằng kiểu hàm, (->) r là một thực thể của Functor. Việc ánh xạ một hàm f lên một hàm g sẽ tạo ra một hàm nhận vào thứ mà g nhận vào, rồi áp dụng g đối với nó, tiếp theo áp dụng f đối với kết quả thu được. Như vậy về cơ bản là ta đang tạo một hàm mới giống như g, chỉ khác là trước khi trả về kết quả, thì lại cho f áp dụng lên kết quả đó. Chẳng hạn:

ghci> let f = (*5)
ghci> let g = (+3)
ghci> (fmap f g) 8
55
Ta cũng đã thấy rằng các hàm là các functor áp dụng. Nó cho phép ta thao tác trên kết quả cuối cùng của các hàm, như thể ta đã có trong tay kết quả đó rồi. Sau đây là một ví dụ:

ghci> let f = (+) <$> (*2) <*> (+10)
ghci> f 3
19
Biểu thức (+) <$> (*2) <*> (+10) tạo lập một hàm để nhận vào một số, đưa số đó cho (*2) và (+10) rồi cộng các kết quả lại. Chẳng hạn, nếu ta áp dụng hàm này cho 3, nó sẽ áp dụng cả (*2) và (+10) cho 3, kết quả là 6 và 13. Sau đó, nó gọi (+) với 6 và 13 để có được kết quả 19.

Kiểu hàm (->) r không chỉ là một functor và functor áp dụng, mà nó còn là một Monad. Cũng như các giá trị Monad khác mà ta đã bắt gặp, một hàm cũng có thể được coi là giá trị kèm theo ngữ cảnh. Ngữ cảnh của hàm thể hiện ở chỗ giá trị đó vẫn chưa xuất hiện và ta phải áp dụng hàm này đối với thứ gì đó để thu được giá trị kết quả.

Vì đã quen với cách mà hàm hoạt động như những functor và functor áp dụng, nên ta hãy đi thẳng vảo vấn đề và xem thực thể Monad của chúng trông ra sao. Thực thể này nằm ở Control.Monad.Instances và nó trông như sau:

instance Monad ((->) r) where
    return x = \_ -> x
    h >>= f = \w -> f (h w) w
Ta đã thấy cách tạo lập pure đối với các hàm, và return khá giống với pure như thế nào. Nó nhận một giá trị rồi đặt nó vào trong ngữ cảnh tối thiểu mà luôn có kết quả là giá trị này. Và cách làm duy nhất khiến cho hàm luôn có kết quả là một giá trị nhất định, đó làm khiến cho hàm này phớt lờ các tham số được cung cấp.

Cách tạo lập >>= có vẻ khá bí hiểm, song thực ra chưa đến nỗi như vậy. Khi ta dùng >>= để đưa một giá trị Monad vào trong một hàm, thì kết quả luôn là một giá trị Monad. Như vậy trong trường hợp này, khi ta đưa một hàm vào cho hàm khác, thì kết quả cũng là một hàm. Điều này giải thích tại sao mà kết quả xuất hiện là lambda. Tất cả phần thiết lập >>= tới giờ đều có sự phân tách nhất định giữa kết quả và giá trị Monad, sau đó áp dụng hàm
f đối với kết quả đó. Ở đây điều tương tự cũng diễn ra. Để lấy được kết quả từ một hàm, ta phải áp dụng hàm này cho một thứ gì đó, và đó là nguyên nhân mà ta đã viết (h w) để lấy kết quả từ hàm rồi áp dụng f đối với kết quả này. f trả về một giá trị Monad, trong trường hợp này là một hàm, vì vậy ta cũng cáp dụng nó cho w.

Nếu đến giờ bạn vẫn chưa nắm được cách hoạt động của >>=, thì đừng lo, vì bằng những ví dụ chúng ta sẽ thấy được đây là một Monad đơn giản chừng nào. Sau đây là một biểu thức do trong đó tận dụng Monad này:

import Control.Monad.Instances

addStuff :: Int -> Int
addStuff = do
    a <- (*2)
    b <- (+10)
    return (a+b)
Cách này cũng giống như biểu thức áp dụng mà ta đã viết trước đây, chỉ khác là bây giờ nó dựa trên các hàm Monad. Một biểu thức do luôn cho kết quả là một giá trị Monad, và với biểu thức này cũng chẳng khác gì. Kết quả của giá trị Monad này là một hàm. Điều xảy ra ở đây là hàm này nhận một số rồi cho (*2) áp dụng với số đó và kết quả là a. (+10) cũng được áp dụng với số ban đầu (mà ta áp dụng (*2) với), lần này kết quả là b. return, cũng như ở các Monad khác, không có hiệu ứng gì khác ngoài việc khiến cho một giá trị Monad biểu diễn một kết quả nào đó. Nó biểu diễn a+b là kết quả của hàm đang xét. Nếu chạy thử, ta thu được kết quả giống như trước:

ghci> addStuff 3
19
Trong trường hợp này, cả hai (*2) và (+10) đều được áp dụng đối với số 3. return (a+b) cũng làm vậy, nhưng nó phớt lờ đi và luôn biểu diễn kết quả là a+b. Bởi thế, Monad hàm còn được gọi là Monad đọc (reader). Tất cả các hàm loại này đều đọc từ một nguồn dữ liệu chung. Để minh họa điều này rõ hơn, ta có thể viết lại addStuff như sau:

addStuff :: Int -> Int
addStuff x = let
    a = (*2) x
    b = (+10) x
    in a+b
Ta thấy rằng Monad đọc cho phép coi các hàm như là những giá trị kèm theo ngữ cảnh. Ta có thể giả như đã biết rằng các hàm đó trả về thứ gì rồi. Nó làm được điều này bằng cách kết dính các hàm lại làm một rồi đưa tham số của hàm đó tất tất cả những hàm dính cùng. Như vậy, nếu ta có nhiều hàm cùng khuyết mất một tham số và cùng phải được áp dụng với một giá trị, thì ta có thể dùng Monad đọc để kết xuất các giá trị tương lai từ những hàm này và cách tạo lập của >>= sẽ đảm bảo rằng mọi việc được thực hiện đúng.


Các đại lượng mang trạng thái
don't jest with texas

Haskell là một ngôn ngữ lập trình thuần túy và bởi vậy, chương trình ta viết ra được cấu thành từ các hàm mà không thể thay đổi trạng thái toàn cục, hoặc thay đổi các biến, chúng chỉ có thể thực hiện những phép tính và trả về kết quả. Mặt hạn chế này thực ra lại khiến cho việc tư duy về chương trình trở nên dễ dàng hơn, vì nó cho phép ta khỏi phải lo lắng về giá trị của từng biến tại một thời điểm nhất định. Tuy nhiên, một số bài toán bản thân chúng đã mang tính trạng thái, theo nghĩa là chúng dựa trên một trạng thái nào đó vốn thay đổi theo thời gian. Dù đó không phải là khó khăn đáng kể đối với Haskell, nhưng vẫn có thể gây nhàm chán khi phải lập mô hình. Vì vậy, Haskell có một tính năng gọi tên là Monad trạng thái, khiến cho việc xử lý các bài toán trạng thái trở nên nhẹ nhàng trong khi vẫn giữ được nét đẹp và thuần túy trong lập trình.

Khi xử lý các số ngẫu nhiên, ta đã làm việc với những hàm nhận tham số là bộ phát sinh số ngẫu nhiên rồi trả về một số ngẫu nhiên cùng bộ phát sinh mới. Nếu ta muốn phát sinh nhiều số ngẫu nhiên, ta luôn phải dùng bộ phát sinh ngẫu nhiên mà hàm trước đó đã trả về cùng với kết quả. Khi lập một hàm nhận một StdGen rồi mô phỏng việc tung đồng xu ba lần dựa theo bộ phát sinh đó, thì ta đã phải viết mã lệnh sau:

threeCoins :: StdGen -> (Bool, Bool, Bool)
threeCoins gen = 
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)
Hàm này nhận một bộ phát sinh gen rồi random gen trả về một giá trị Bool đi cùng với một bộ phát sinh mới. Để tung đồng xu thứ hai, ta đã dùng một bộ phát sinh mới, và cứ như vậy. Trong đa số các ngôn ngữ lập trình khác, ta đã chẳng phải trả về một bộ phát sinh mới đi cùng số ngẫu nhiên. Ta chỉ việc sửa lại bộ phát sinh hiện có! Nhưng vì Haskell mang tính thuần túy, nên ta không thể làm điều đó, vì thế ta đã phải lấy trạng thái nào đó, tạo ra một kết quả và một trạng thái mới, rồi dùng trạng thái mới để phát sinh những kết quả mới.

Bạn có thể đã nghĩ rằng để tự tránh khỏi những tính toán với trạng thái theo cách làm này, thì ta phải từ bỏ tính thuần khiết của Haskell. À, không nhất thiết vậy, vì vẫn có một Monad đặc biệt, gọi là Monad trạng thái để giúp ta đảm nhiệm tất cả những trạng thái mà không xâm phạm đến tính thuần khiết và vì vậy lập trình Haskell rất tuyệt.

Như vậy, để giúp ta hiểu rõ hơn khái niệm về đại lượng có trạng thái, hãy tiến thêm một bước nữa bằng cách cho những đại lượng này một kiểu dữ liệu. Ta sẽ nói rằng một đại lượng có trạng thái là một hàm nhận vào một trạng thái nào đó rồi trả về một giá trị cùng với một trạng thái mới. Hàm đó sẽ phải có kiểu sau đây:

s -> (a,s)
s là kiểu của trạng thái còn a là kết quả của những phép tính có trạng thái.

Phép gán, trong hầu hết những ngôn ngữ lập trình khác, có thể được coi như là đại lượng trạng thái. Chẳng hạn, khi ta viết x = 5 trong một ngôn ngữ mệnh lệnh, nó sẽ thường đưa giá trị 5 cho biến x và bản thân đại lượng này cũng có giá trị 5 như một biểu thức. Nếu bạn xét trên quan điểm lập trình hàm, thì bạn có thể coi phép gán như một hàm nhận vào một trạng thái (nghĩa là, tất cả những biến đã được gán trước đó) rồi trả về một kết quả (trong trường hợp này là 5) và một trạng thái mới, vốn là tất cả những ánh xạ đến biến trước đó, và thêm vào biến mới gán.
Đại lượng trạng thái này, một hàm nhận vào một trạng thái và trả về một kết quả cùng một trạng thái mới, cũng có thể được coi là một giá trị kèm ngữ cảnh. Giá trị này là kết quả, còn ngữ cảnh là thứ mà ta phải cung cấp cho một trạng thái ban đầu mới thu được kết quả đó, và ngoài việc có được kết quả ta cũng có một trạng thái mới.

NGĂN XẾP VÀ NHỮNG KHỐI ĐÁ
Giả dụ ta cần phải mô phỏng một ngăn xếp. Bạn có ngăn xếp với các thứ chồng lên nhau mà có thể chất từng thứ lên đỉnh ngăn xếp hoặc lấy từng thứ khỏi đỉnh ngăn xếp. Khi bạn chất một thứ lên đỉnh ngăn xếp thì ta gọi là “đẩy” (push) vào ngăn xếp, còn khi lấy một thứ khỏi đỉnh ngăn xếp thì gọi là “bung” (pop). Nếu muốn lấy được thứ ở đáy ngăn xếp, bạn phải bung tất cả các thứ bên trên nó.

Ta sẽ dùng một list để biểu diễn cho ngăn xếp và phần tử đầu list sẽ là đỉnh của ngăn xếp. Để giúp giải quyết nhiệm vụ sắp tới, ta sẽ lập hai hàm: pop và push. pop sẽ lấy một ngăn xếp, bung ra một phần tử và trả về kết quả là phần tử này cùng với một ngăn xếp mới khuyết mất phần tử đó. push sẽ nhận một phần tử và một ngăn xếp rồi đẩy phần tử đó vào ngăn xếp. Hàm này sẽ trả về kết quả là () và một ngăn xếp mới. Xem này:

type Stack = [Int]

pop :: Stack -> (Int,Stack)
pop (x:xs) = (x,xs)

push :: Int -> Stack -> ((),Stack)
push a xs = ((),a:xs)
Ta đã để kết quả là () khi đẩy vào ngăn xếp, bởi vì việc đẩy phần tử vào list thì không có một giá trị kết quả quan trọng nào, nhiệm vụ chính của nó là làm thay đổi ngăn xếp. Lưu ý cách mà ta chỉ việc áp dụng tham số thứ nhất của push, ta có một đại lượng trạng thái. pop thì đã sẵn là một đại lượng trạng thái, căn cứ vào kiểu của nó.

Ta hãy dùng các hàm này để viết một đoạn mã lệnh ngắn để mô phỏng một ngăn xếp. Ta sẽ lấy một ngăn xếp, đẩy 3 vào, rồi bung hai phần tử ra, chỉ để thử cho vui. Sau đây là mã lệnh:

stackManip :: Stack -> (Int, Stack)
stackManip stack = let
    ((),newStack1) = push 3 stack
    (a ,newStack2) = pop newStack1
    in pop newStack2
Ta lấy một stack rồi thực hiện push 3 stack, kết quả thu được là một bộ. Phần đầu của bộ là một () còn phần thứ hai là một ngăn xếp mới mà ta gọi là newStack1. Sau đó, ta bung một con số từ newStack1, kết quả là một số a (chính là 3) mà ta vừa đẩy vào, cùng một ngăn xếp mới mà ta gọi là newStack2. Sau đó, ta bung một con số khỏi newStack2 và nhận được một số tên là b cùng một newStack3. Ta trả về một bộ chứa số đó và ngăn xếp mới. Hãy thử chạy mã lệnh xem:

ghci> stackManip [5,8,2,1]
(5,[8,2,1])
Tuyệt, kết quả là 5 còn ngăn xếp mới là [8,2,1]. Lưu ý rằng stackManip bản thân nó là một đại lượng trạng thái ra sao. Ta đã lấy một loạt những đại lượng trạng thái rồi kết dính chúng với nhau. Hừm, nghe có vẻ quen quen.

Đoạn mã lệnh stackManip trên phần nào thật tẻ nhạt vì ta phải tự đưa trạng thái vòa cho mỗi đại lượng trạng thái, và lưu chúng lại rồi đưa nó vào đại lượng trạng thái tiếp theo. Chẳng phải sẽ hay hơn nếu, thay vì phải đưa ngăn xếp vào cho từng hàm, ta có thể viết như sau:

stackManip = do
    push 3
    a <- pop
    pop
À, dùng Monad trạng thái sẽ cho phép ta thực hiện đúng điều này. Với Monad trạng thái, ta sẽ có thể nhận các đại lượng trạng thái, như ở đây, và dùng chúng mà không phải tự quản lý trạng thái.

Monad STATE
Module Control.Monad.State cung cấp một newtype để bọc các đại lượng trạng thái. Sau đây là lời định nghĩa của nó:

newtype State s a = State { runState :: s -> (a,s) }
State s a là một đại lượng trạng thái để thao tác trên trjangthasi thuộc kiểu s và có một kết quả thuộc kiểu a.

Bây giờ, khi đã thấy được các đại lượng trạng thái là gì rồi, và chúng thậm chí có thể được hình dung như giá trị kèm ngữ cảnh ra sao, ta hãy kiểm tra thực thể Monad của chúng:

instance Monad (State s) where
    return x = State $ \s -> (x,s)
    (State h) >>= f = State $ \s -> let (a, newState) = h s
                                        (State g) = f a
                                    in  g newState
Trước hết ta hãy xét return. Mục đích của ta khi dùng return là nhận một giá trị rồi tạo một đại lượng trạng thái luôn có kết quả là giá trị này. Đó là lý do mà ta lập một lambda \s -> (x,s). Ta luôn biểu diễn x như là kết quả của đại lượng trạng thái và trạng thái này luôn được giữ không đổi, vì return phải đặt một giá trị vào trong một ngữ cảnh tối thiểu. Vì vậy return sẽ làm cho một đại lượng trạng thái vốn biểu diễn cho một giá trị nhất định làm kết quả và giữ cho trạng thái không thay đổi.

im a cop

Thế còn về >>=? À, kết quả của việc đưa một đại lượng trạng thái vào một hàm bằng >>= thì phải là một đại lượng trạng thái, nhỉ? Vậy ta hãy bắt đầu bằng gói bọc newtype State rồi viết tiếp một lambda. Cái lambda này sẽ là đại lượng trạng thái mới của ta. Nhưng điều gì đang diễn ra trong nó? À, bằng cách nào đó ta phải kết xuất giá trị kết quả từ đại lượng trạng thái thứ nhất. Vì ta hiện giờ đang ở trong một đại lượng trạng thái, nên ta có thể cho đại lượng trạng thái h một đại lượng trạng thái s của ta, và điều này dẫn đến một cặp gồm kết quả và một trạng thái mới: (a, newState). Đến giờ, mỗi lần khi lập ra >>=, một khi đã kết xuất được kết quả từ giá trị Monad thì ta áp dụng hàm f đối với nó để thu được giá trị Monad mới. Trong Writer, sau khi làm điều này và thu được giá trị Monad mới, ta vẫn phải đảm bảo rằng ngữ cảnh được để ý đến bằng cách mappend giá trị Monoid cũ với cái mới. Ở đây, ta viết f a và thu được một đại lượng trạng thái mới là g. Bây giờ khi đã có một đại lượng trạng thái mới và một trạng thái mới (có tên newState), ta chỉ việc áp dụng đại lượng trạng thái g đó cho newState. Kết quả là một bộ gồm kết quả cuối cùng và trạng thái cuối cùng!

Như vậy với >>=, ta đã dính liền hai đại lượng với nhau, chỉ có điều là đại lượng thứ hai được giấu trong một hàm có nhiệm vụ nhận kết quả từ đại lượng thứ nhất. Vì pop và push đều đã là các đại lượng trạng thái, nên ta dễ dàng gói chúng vào trong một vỏ bọc State. Xem này:

import Control.Monad.State

pop :: State Stack Int
pop = State $ \(x:xs) -> (x,xs)

push :: Int -> State Stack ()
push a = State $ \xs -> ((),a:xs)
pop đã là một đại lượng trạng thái còn push nhận một Int rồi trả về một đại lượng trạng thái. Bây giờ ta có thể viết lại ví dụ trước, trong đó đẩy 3 vào ngăn xếp rồi bung ra hai con số, như sau:

import Control.Monad.State

stackManip :: State Stack Int
stackManip = do
    push 3
    a <- pop
    pop
Bạn đã thấy việc ta dính liền một phép đẩy và hai phép bung vào cùng một đại lượng trạng thái chưa? Khi tháo gỡ nó từ vỏ bọc newtype ta thu được một hàm mà có thể cung cấp cho nó một trạng thái ban đầu nào đó:

ghci> runState stackManip [5,8,2,1]
(5,[8,2,1])
Ta không phải buộc cái pop thứ hai vào cho a vì không hề sử dụng cái a đó chút nào. Vì vậy ta đã có thể viết lại mã lệnh như sau:

stackManip :: State Stack Int
stackManip = do
    push 3
    pop
    pop
Khá hay. Nhưng sẽ ra sao nếu ta muốn làm thế này: bung một số ra khỏi ngăn xếp rồi xem liệu số đó có bằng 5, nếu đúng thì đẩy trở lại ngăn xếp và dừng chương trình; còn nếu không phải 5, thì đẩy 3 và 8 trở lại? Ồ, đây là đoạn mã lệnh:

stackStuff :: State Stack ()
stackStuff = do
    a <- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8
Cách này khá trực tiếp. Ta hãy chạy nó với một ngăn xếp ban đầu.

ghci> runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])
Hãy nhớ rằng, các biểu thức do cho kết quả là những giá trị Monad và với Monad State, thì một biểu thức do cũng là một hàm trạng thái. Vì stackManip và stackStuff là các đại lượng trạng thái thông thường, nên ta có thể gắn chúng lại để tạo thành những đại lượng trạng thái tiếp theo.

moreStack :: State Stack ()
moreStack = do
    a <- stackManip
    if a == 100
        then stackStuff
        else return ()
Nếu như kết quả của stackManip trên ngăn xếp hiện thời bằng 100, thì ta chạy stackStuff, còn nếu không thì ta không làm gì cả. return () chỉ để giữ nguyên trạng thái và không làm gì cả.

Module Control.Monad.State cung cấp một lớp có tên MonadState; lớp này có hai hàm hữu ích là get và put. Đối với State, hàm get được thiết lập như sau:

get = State $ \s -> (s,s)
Như vậy nó chỉ lấy trạng thái hiện thời rồi thể hiện nó dưới dạng kết quả. Hàm put nhận một trạng thái nào đó rồi lập một hàm trạng thái để thay thế trạng thái hiện thời:

put newState = State $ \s -> ((),newState)
Như vậy bằng những hàm này, ta có thể xem ngăn xếp hiện thời gồm có gì hoặc có thể thay thế nó bằng cả một ngăn xếp khác. Chẳng hạn:

stackyStack :: State Stack ()
stackyStack = do
    stackNow <- get
    if stackNow == [1,2,3]
        then put [8,3,1]
        else put [9,2,1]
Cũng cần phải kiểm tra xem kiểu dữ liệu của >>= sẽ là gì nếu nó chỉ làm việc đối với các giá trị State:

(>>=) :: State s a -> (a -> State s b) -> State s b
Bạn đã thấy rằng kiểu của trạng thái s vẫn giữ nguyên trong khi kiểu của kết quả thì thay đổi từ a sang b rồi chứ? Điều này có nghĩa rằng ta có thể gắn nhiều đại lượng trạng thái có kết quả thuộc những kiểu khác nhau nhưng kiểu của trạng thái phải giữ nguyên. Tại sao phải vậy? Ồ, chẳng hạn, đối với Maybe, thì >>= có kiểu sau:

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
Việc bản thân Monad, Maybe, không thay đổi là có lý. Sẽ không có lý gì khi dùng >>= giữa hai Monad riêng biệt. Ồ, đối với Monad trạng thái, thì thực ra Monad này là State s, vì vậy nếu s khác đi, thì ta đã dùng >>= giữa hai Monad riêng biệt.

SỰ NGẪU NHIÊN Monad TRẠNG THÁI
Ở phần đầu của mục này, ta đã thấy được việc phát sinh các số có thể rất lủng củng vì mỗi hàm ngẫu nhiên nhận một generator rồi trả về một số ngẫu nhiên kèm theo một bộ phát sinh mới, vốn sau đó dược dùng thay cho bộ cũ nếu ta muốn phát sinh một số ngẫu nhiên khác. The Monad trạng thái giúp cho việc xử lý dễ hơn nhiều.

Hàm random trong System.Random có kiểu dữ liệu sau:

random :: (RandomGen g, Random a) => g -> (a, g)
Điều này có nghĩa là nó nhận một bộ phát sinh ngẫu nhiên rồi tạo ra một số ngẫu nhiên cùng một bộ phát sinh mới. Ta có thể thấy rằng nó là một đại lượng trạng thái, vì vậy có thể bọc nó vào trong constructor newtype State rồi dùng nó như một giá trị Monad, theo đó việc truyền trạng thái được thực hiện giúp ta:

import System.Random
import Control.Monad.State

randomSt :: (RandomGen g, Random a) => State g a
randomSt = State random
Như vậy nếu bây giờ ta muốn tung ba đồng xu (True là sấp, False là ngửa) ta chỉ cần viết như sau:

import System.Random
import Control.Monad.State

threeCoins :: State StdGen (Bool,Bool,Bool)
threeCoins = do
    a <- randomSt
    b <- randomSt
    c <- randomSt
    return (a,b,c)
Bây giờ threeCoins là một đại lượng trạng thái và sau khi nhận một bộ phát sinh ngẫu nhiên ban đầu, hàm đó truyền bộ phát này cho randomSt đầu tiên, đến lượt nó lại tạo ra một số cùng một bộ phát sinh mới, vốn được truyền đến hàm tiếp theo, rồi cứ như vậy. Ta dùng return (a,b,c) để biểu diễn (a,b,c) làm kết quả mà không thay đổi bộ phát sinh gần nhất. Hãy thử chạy mã lệnh này:

ghci> runState threeCoins (mkStdGen 33)
((True,False,True),680029187 2103410263)
Hay rồi. Thực hiện những việc kiểu như thế này luôn yêu cầu phải giữ một rạng thái nào đó giữa các bước thao tác đã trở nên đỡ phiền toái hơn!


Lỗi sai
Đến giờ ta đã biết rằng Maybe được dùng để thêm vào các giá trị một ngữ cảnh chứa thất bại khả dĩ. Một giá trị có thể là Just something hoặc Nothing. Dù chúng có ích, nhưng khi ta có Nothing, thì tất cả những gì ta biết được là có lỗi nào đó đã xảy ra, nhưng không còn cách nào để moi thêm thông tin gì về loại lỗi đó là gì, hoặc tại sao tính toán lại thất bại.

Ngược lại, kiểu Either e a cho phép ta kèm thêm vào trong các giá trị hiện có, một ngữ cảnh chứa thất bại có thể xảy ra, trong khi vẫn có thể gắn những giá trị vào trong thất bại này, để chúng có thể mô tả được nguyên nhân hỏng hóc hoặc cung cấp những thông tin khác về thất bại này. Một giá trị Either e a có thể hoặc là một giá trị Right, để chỉ đáp số đúng hay sự thành công, hoặc một giá trị Left, để chỉ thất bại. Chẳng hạn:

ghci> :t Right 4
Right 4 :: (Num t) => Either a t
ghci> :t Left "out of cheese error"
Left "out of cheese error" :: Either [Char] b
Đây gần như là một dạng Maybe được cải tiến, vì vậy để nó là một Monad thật hợp lý, vì cũng có thể coi nó như một giá trị với ngữ cảnh kèm theo để chỉ thất bại khả dĩ, chỉ khác là bây giờ có một giá trị cùng với cả lỗi nữa.

Thực thể Monad của nó thì giống như với Maybe và bạn có thể tìm thấy nó trong Control.Monad.Error:

instance (Error e) => Monad (Either e) where
    return x = Right x 
    Right x >>= f = f x
    Left err >>= f = Left err
    fail msg = Left (strMsg msg)
return, như thường lệ, nhận một giá trị rồi đặt nó vào trong một ngữ cảnh tối thiểu mặc định. Nó bọc giá trị đang xét vào trong constructor Right vì ta đang dùng Right để biểu diễn một đại lượng tính toán thành công trong đó có một kết quả. Điều này rất giống với return của Maybe.

Phép >>= kiểm tra hai trường hợp khả dĩ: Left và Right. Trong trường hợp Right, hàm f được áp dụng cho giá trị bên trong nó, cũng giống như cách làm trong trường hợp với Just, hàm được áp dụng ngay cho nội dung của nó. Trong trường hợp có lỗi, giá trị Left được giữ lại, cùng với nội dung của nó, để mô tả sự thất bại.

Thực thể Monad của Either e tạo nên một yêu cầu phụ thêm, đó là kiểu của giá trị chứa trong Left, cái mà được đánh chỉ số bằng tham số kiểu e, phải là một thực thể của lớp Error. Lớp Error được dành cho những kiểu mà các giá trị có thể đóng vai trò thông báo lỗi. Lớp này định nghĩa hàm strMsg, vốn nhận một lỗi dưới dạng chuỗi rồi trả về một giá trị như vậy. Một ví dụ điển hình cho một thực thể Error là, a hèm, kiểu String! Trong trường hợp với String, hàm strMsg chỉ việc trả về chuỗi mà nó nhận vào:

ghci> :t strMsg
strMsg :: (Error a) => String -> a
ghci> strMsg "boom!" :: String
"boom!"
Nhưng vì ta thường dùng String để mô tả lỗi khi dùng Either, nên ta sẽ không cần quá lo lắng về điều này. Khi việc khớp mẫu thất bại trong khối lệnh do, thì một giá trị Left được dùng để chỉ sự thất bại này.

Dù sao, ta hãy xem một vài ví dụ áp dụng:

ghci> Left "boom" >>= \x -> return (x+1)
Left "boom"
ghci> Right 100 >>= \x -> Left "no way!"
Left "no way!"
Khi ta dùng >>= để đưa một giá trị Left vào một hàm, thì hàm này sẽ bị phớt lờ đi và một giá trị Left giống hệt nó sẽ được trả về. Khi ta đưa một giá trị Right vào một hàm, thì hàm này sẽ áp dụng cho thứ nằm bên trong nó, nhưng trong trường hợp như vậy hàm đó vẫn sẽ tạo ra một giá trị Left!

Khi ta thử đưa một giá trị Right vào một hàm tính toán thành công, ta sẽ mắc phải một loại lỗi rất riêng! Hừm.

ghci> Right 3 >>= \x -> return (x + 100)

<interactive>:1:0:
    Ambiguous type variable `a' in the constraints:
      `Error a' arising from a use of `it' at <interactive>:1:0-33
      `Show a' arising from a use of `print' at <interactive>:1:0-33
    Probable fix: add a type signature that fixes these type variable(s)
Haskell nói rằng nó khong biết chọn kiểu dữ liệu gì cho phần e của giá trị mang kiểu Either e a đang xét, ngay cả khi ta chỉ cần in phần Right. Điều này là do ràng buộc Error e trong thực thể Monad. Như vậy nếu bạn nhận được các lỗi kiểu, như lỗi này khi dùng Either làm Monad, thì chỉ cần thêm hẳn một dấu ấn kiểu:

ghci> Right 3 >>= \x -> return (x + 100) :: Either String Int
Right 103
Ổn rồi, bây giờ mã lệnh đã hoạt động!

Trừ vướng mắc nhỏ này ra thì việc dùng Monad này rất giống với việc dùng Maybe làm Monad. Ở chương trước, ta đã dùng những khía cạnh Monad của Maybe để mô phỏng những con chim đậu trên cây sào thăng bằng của người đi trên dây. Bạn hãy thử làm bài tập này: viết lại chương trình đó có dùng đến Monad lỗi để cho khi người đi dây mất thăng bằng và ngã, thì ta còn nhớ lại được có bao nhiêu con chim đậu trên hai đầu cây sào lúc đó.


Một số hàm Monad hữu ích
Trong mục này, ta sẽ tìm hiểu một số hàm hoạt động trên các giá trị Monad hoặc trả về kết quả là giá trị Monad (hoặc là cả hai điều này!). Những hàm như vậy thường được gọ là hàm Monad. Trong khi một số hàm kiểu này là mới toanh, một số khác thì lại là những dạng Monad tương ứng của các hàm ta đã biết, như filter và foldl. Ta hãy xem chúng là gì nhé!

LIFTM CÙNG BẠN BÈ
im a cop too

Khi ta mới khởi đầu chuyến leo lên đỉnh núi Monad Mountain, ta đã nhình đến các functor, vốn được dùng cho những thứ có thể được ánh xạ lên. Sau đó, ta đã học về các functor cải tiến, gọi là functor áp dụng, vốn cho phép ta áp dụng những functor thường đối vói một số giá trị áp dụng, cũng như lấy một giá trị thường rồi đặt nó vao trong một ngữ cảnh mặc định nào đó. Cuối cùng, ta giới thiệu Monad như những functor áp dụng cải tiến, trong đó có bổ sung khả năng giúp những giá trị trên kèm ngữ cảnh được đưa vào các hàm thông thường.

Như vậy mỗi Monad cũng là một functor áp dụng và mỗi functor áp dụng là một functor. Lớp Applicative có một ráng buộc lớp, theo đó kiểu đang xét phải là một thực thể của Functor trước khi ta có thể khiến nó làm thực thể của Applicative. Mặc dù Monad phải có cùng ràng buộc này đối với Applicative, với lý do là mỗi Monad cũng là một functor áp dụng, thì sự thật lại không phải, vì lớp Monad được giới thiệu ở Haskell trước cả Applicative.

Nhưng ngay cả khi mỗi Monad là một functor, ta cũng không phải dựa vào việc nó có một thực thể Functor vì đã có hàm liftM. Hàm này nhận một hàm khác một giá trị Monad rồi ánh xạ hàm mới nhận lên giá trị Monad. Như vậy nó khá giống với fmap! Sau đây là kiểu của liftM:

liftM :: (Monad m) => (a -> b) -> m a -> m b
Và sau đây là kiểu của fmap:

fmap :: (Functor f) => (a -> b) -> f a -> f b
Nếu các thực thể Functor và Monad của một kiểu dữ liệu đều tuân theo các định luật functor và Monad, thì hai thứ này sẽ tương đương nhau (và tất cả những Monad mà ta đã gặp đến giờ đều tuân theo cả hai nhóm định luật). Điều này khá giống như việc pure và return cùng làm một việc, chỉ khác là cái này có ràng buộc lớp Applicative còn cái kia có ràng buộc lớp Monad Ta hãy thử liftM xem:

ghci> liftM (*3) (Just 8)
Just 24
ghci> fmap (*3) (Just 8)
Just 24
ghci> runWriter $ liftM not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci> runWriter $ fmap not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci> runState (liftM (+100) pop) [1,2,3,4]
(101,[2,3,4])
ghci> runState (fmap (+100) pop) [1,2,3,4]
(101,[2,3,4])
Ta đã biết khá rõ rằng fmap thao tác trên các giá trị Maybe như thế nào. Và liftM làm điều tương tự. Với các giá trị Writer, hàm đang xét sẽ được ánh xạ lên thành phần thứ nhất của bộ, vốn là kết quả. Trong quá trình fmap hoặc liftM lên một đại lượng trạng thái để cho ra kết quả là một đại lượng trạng thái khác, chỉ có kết quả cuối cùng mới bị thay đổi bởi hàm kèm theo. Nếu trong trường hợp này, ta đã không ánh xạ (+100) lên pop trước khi chạy nó, thì kết quả trả về đã là (1,[2,3,4]).

Đây là cách mà liftM đã được tạo lập:

liftM :: (Monad m) => (a -> b) -> m a -> m b
liftM f m = m >>= (\x -> return (f x))
Hoặc với khối lệnh do:

liftM :: (Monad m) => (a -> b) -> m a -> m b
liftM f m = do
    x <- m
    return (f x)
Ta đưa giá trị Monad m vào hàm rồi áp dụng hàm f lên kết quả thu được, trước khi đặt nó vào lại ngữ cảnh mặc định. Các định luật Monad đảm bảo rằng việc làm này không làm thay đổi ngữ cảnh, chỉ thay đổi kết quả mà giá trị Monad biểu diễn. Ta thấy rằng liftM được thiết lập mà không hề tham chiếu tới lớp Functor. Điều này có nghĩa là ta có thể thiết lập fmap (hoặc liftM, bạn muốn gọi bằng tên gì cũng được) chỉ bằng cách dùng những ưu điểm mà Monad có. Từ đây, ta có thể kết luận rằng Monad thì mạnh hơn những functor thông thường mà ta đã gặp.

Kiểu Applicative cho phép ta áp dụng các hàm lên những giá trị kèm ngữ cảnh, như thể chúng là những giá trị thông thường. Ví dụ:

ghci> (+) <$> Just 3 <*> Just 5
Just 8
ghci> (+) <$> Just 3 <*> Nothing
Nothing
Dùng cách lập trình áp dụng như vậy làm mọi thứ trở nên đơn giản. <$> chỉ là fmap còn <*> là một hàm trong lớp
Applicative có kiểu như sau:

(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
Như vậy, nó giống với fmap, chỉ có điều là bản thân hàm cũng nằm trong một ngữ cảnh. Bằng cách nào đó, ta phải tách lấy hàm khỏi ngữ cảnh rồi ánh xạ nó lên giá trị f a, tiếp theo là lắp ghép lại ngữ cảnh. Vì theo mặc định, cách hàm trong Haskell đều có tính “curry” nên ta có thể dùng tổ hợp của <$> và <*> để áp dụng các hàm nhận vào nhiều tham số lên các giá trị áp dụng.

Dù sao, hoá ra là cũng giống như fmap, <*> cũng có thể thiết lập được chỉ bằng cách dùng những gì mà lớp Monad cho ta. Hàm ap về cơ bản là <*>, chỉ khác là nó có một ràng buộc Monad thay vì ràng buộc Applicative. Sau đây là lời định nghĩa hàm này:

ap :: (Monad m) => m (a -> b) -> m a -> m b
ap mf m = do
    f <- mf
    x <- m
    return (f x)
mf là một giá trị Monad mà kết quả của nó là một hàm. Vì hàm này nằm trong một ngữ cảnh, cũng như giá trị, nên ta lấy hàm ra khỏi ngữ cảnh rồi gọi nó là f, sau đó lấy giá trị rồi gọi nó là x, và cuối cùng đem áp dụng hàm này lên giá trị và biểu diễn kết quả. Sau đây là ví dụ ngắn gọn:

ghci> Just (+3) <*> Just 4
Just 7
ghci> Just (+3) `ap` Just 4
Just 7
ghci> [(+1),(+2),(+3)] <*> [10,11]
[11,12,12,13,13,14]
ghci> [(+1),(+2),(+3)] `ap` [10,11]
[11,12,12,13,13,14]
Bây giờ ta đã thấy được rằng các Monad cũng mạnh hơn các đối tượng áp dụng (applicative), vì ta có thể dùng các hàm trong Monad để thiết lập những hàm của Applicative. Thực ra, nhiều khi một kiểu dữ liệu được coi là Monad, đầu tiên người ta thường viết ra một thực thể Monad rồi sau đó lập thực thể Applicative chỉ bằng việc khẳng định rằng pure là return và <*> là ap. Tương tự, nếu bạn đã có một thực thể Monad của một đối tượng nào đó, bạn có thể cho nó một thực thể Functor chỉ bằng cách nói rằng fmap là liftM.

Hàm liftA2 là một hàm tiện lợi để áp dụng một hàm lên hai giá trị áp dụng. Nó được định nghĩa đơn giản như sau:

liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f x y = f <$> x <*> y
Hàm liftM2 làm điều tương tự, chỉ khác là nó có một ràng buộc Monad. Cũng có các hàm liftM3, liftM4 và liftM5.

Ta đã thấy bằng cách nào mà Monad mạnh hơn các đối tượng áp dụng cùng các functor và việc mặc dù mọi Monad đều là functor và functor áp dụng, nhưng chúng không nhất thiết có các thực thể Functor và Applicative, nên ta đã kiểm tra các dạng Monad tương đương của các hàm mà functor và functor áp dụng dùng đến.

HÀM “JOIN”
Sau đây là một số điều cần suy ngẫm: nếu kết quả của một giá trị Monad lại là một giá trị Monad khác, nghĩa là nếu một giá trị Monad được lồng vào trong giá trị kia, liệu bạn có thể duỗi thẳng chúng ra thành một giá trị Monad thông thường chứ? Chẳng hạn, nếu có Just (Just 9), ta có thể biến nó thành Just 9 không? Hóa ra rằng bất kì giá trị Monad lồng ghép nào cũng có thể duỗi thẳng được, và đây thực ra là một thuộc tính riêng của Monad. Để làm việc này, đã có hàm join. Kiểu của nó như sau:

join :: (Monad m) => m (m a) -> m a
Như vậy hàm nhận một giá trị Monad nằm trong một giá trị Monad rồi cho ta một giá trị Monad, như vậy đại loại là nó đã thực hiện việc duỗi thẳng. Sau đây là cách dùng hàm với một số giá trị Maybe:

ghci> join (Just (Just 9))
Just 9
ghci> join (Just Nothing)
Nothing
ghci> join Nothing
Nothing
Dòng đầu tiên có một đại lượng tính toán thành công, là kết quả của một đại lượng thành công khác, vậy chúng đơn giản là được ghép nối lại thành một đại lượng thành công lớn hơn. Dòng lệnh thứ hai có Nothing là kết quả của một giá trị Just. Trước đây, mỗi khi ta xử lý các giá trị Maybe và muốn kết hợp nhiều giá trị này lại làm một, bất kể nó là <*> hoặc >>=, chúng đều phải là Just thì kết quả mới là một giá trị Just. Nếu bất kì thất bại nào đó xảy ra trong quá trình tính, thì kết quả sẽ là thất bại, và điều tương tự cũng diễn ra ở đây. Trong dòng lệnh thứ ba, ta đã thử duỗi thẳng thứ mà khởi nguồn là một thất bại, nên kết quả cũng là thất bại.

Việc duỗi thẳng list khá là trực quan:

ghci> join [[1,2,3],[4,5,6]]
[1,2,3,4,5,6]
Bạn thấy đấy, với list, join chỉ là concat. Để duỗi thẳng một giá trị Writer mà kết quả cũng là một giá trị Writer khác, ta phải thực hiện mappend với giá trị Monoid.

ghci> runWriter $ join (Writer (Writer (1,"aaa"),"bbb"))
(1,"bbbaaa")
Giá trị Monoid ở ngoài, "bbb" được xử lý trước và tiếp theo "aaa" được nối vào. Xét theo trực giác, khi bạn muốn kiểm tra xem giá trị của Writer là gì, trước hết bạn phải viết giá trị Monoid của nó vào nội dung ghi chép rồi mới kiểm tra được xem bên trong có gì.

Việc duỗi thẳng những giá trị Either rất giống với việc duỗi thẳng các giá trị Maybe:

ghci> join (Right (Right 9)) :: Either String Int
Right 9
ghci> join (Right (Left "error")) :: Either String Int
Left "error"
ghci> join (Left "error") :: Either String Int
Left "error"
Nếu ta áp dụng join lên một đại lượng trạng thái với kết quả là một đại lượng trạng thái, thì kết quả sẽ là một đại lượng trạng thái mà trước hết hoạt động với đại lượng trạng thái bên ngoài tiếp theo là đại lượng kết quả. Xem này:

ghci> runState (join (State $ \s -> (push 10,1:2:s))) [0,0,0]
((),[10,1,2,0,0,0])
Ở đây lambda nhận một trạng thái rồi đặt 2 và 1 lên ngăn xếp rồi biểu diễn push 10 làm kết quả. Như vậy khi toàn bộ cái này được duỗi thẳng bằng join và rồi chạy, thì trước hết 2 và 1 được đặt lên ngăn xếp rồi push 10 được thực thi, đẩy số 10 lên đỉnh ngăn xếp.

Cách thiết lập join như sau:

join :: (Monad m) => m (m a) -> m a
join mm = do
    m <- mm
    m
Vì kết quả của mm là một giá trị Monad, ta đem lấy giá trị đó rồi chỉ việc đặt vào một dòng lệnh riêng vì nó là một giá trị Monad. Mẹo ở đây là khi ta viết m <- mm, ngữ cảnh của Monad mà ta đang xét sẽ được theo dõi. Điều này giải thích tại sao, chẳng hạn, các giá trị Maybe cho kết quả là các giá trị Just chỉ khi các giá trị ngoài và trong đều là những giá trị Just. Điều này sẽ được cho thấy như sau đây, nếu giá trị mm được gán trước là Just (Just 8):

joinedMaybes :: Maybe Int
joinedMaybes = do
    m <- Just (Just 8)
    m
im a cop too as well also

Có lẽ điều hay nhất ở join là đối với mỗi Monad, việc đưa một giá trị Monad vào một hàm bằng >>= cũng giống như chỉ việc ánh xạ hàm đó lên giá trị rồi dùng join để duỗi thẳng giá trị Monad lồng ghép thu được! Nói cách khác, m >>= f luôn giống như join (fmap f m)! Nếu suy nghĩ, bạn sẽ thấy điều này hoàn toàn có lý. Bằng >>=, ta luôn nghĩ về cách đưa một giá trị Monad vào cho một hàm nhận giá trị thường nhưng trả về một giá trị Monad. Nếu ta chỉ ánh xạ hàm đó lên giá trị Monad, ta sẽ có một giá trị Monad bên trong một giá trị Monad khác. Chẳng hạn, giả dụ ta có Just 9 và hàm là \x -> Just (x+1). Nếu ánh xạ hàm này lên Just 9, ta thu được Just (Just 10).

Việc m >>= f luôn bằng join (fmap f m) rất có ích nếu ta tự lập nên thực thể Monad của một kiểu dữ liệu nào đó, vì thường sẽ dễ hơn nếu ta hình dung cách duỗi thẳng một giá trị Monad lồng ghép hơn là việc hình dung ra cách lập >>=.

FILTERM
Hàm filter chính là một phần cốt lõi của lập trình Haskell (map là một phần cốt lõi khác). Hàm này nhận một vị từ cùng một list cần lọc rồi trả về một list mới trong đó chỉ còn lại những phần tử thỏa mãn vị từ. Kiểu của hàm như sau:

filter :: (a -> Bool) -> [a] -> [a]
Vị từ nhận vào một phần tử thuộc list rồi trả về một giá trị Bool . Bây giờ, sẽ ra sao nếu giá trị Bool mà nó trả về là một giá trị Monad? Ôi! Nghĩa là, nếu nó đi cùng với một ngữ cảnh? Liệu chương trình có hoạt động không? Chẳng hạn, sẽ ra sao nếu mỗi giá trị True hoặc False mà vị từ tạo ra cũng có một giá trị Monoid tương ứng, như ["Accepted the number 5"] hoặc ["3 is too small"]? Nghe có vẻ cũng hoạt động được đấy. Nếu như vậy, thì ta sẽ trông đợi list kết quả cũng gồm có nội dung ghi chép chứa tất cả những giá trị ghi chép được tạo ra trong quá trình thực hiện. Như vậy, nếu giá trị Bool mà vị trừ trả về đi cùng với một ngữ cảnh, thì ta trông đợi rằng list kết quả cuối cùng cũng sẽ có một ngữ cảnh gắn kèm, nếu không thì ngữ cảnh đi theo từng Bool sẽ mất đi.

Hàm filterM trong Control.Monad
thực hiện đúng điều ta mong muốn! Hàm này có kiểu như sau:

filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
Vị từ trả về một giá trị Monad có kết quả là một Bool, nhưng vì nó là một giá trị Monad, nên ngữ cảnh có thể là bất kì điều gì, từ thất bại có thể xảy ra, đến giá trị không tất định, và còn hơn thế nữa! Để đảm bảo rằng ngữ cảnh được phản ánh trong kết quả cuối cùng, thì kết quả này cũng phải là một giá trị Monad.

Ta hãy lấy một list rồi chỉ giữ lại những giá trị nào nhỏ hơn 4. Ta sẽ bắt đầu bằng việc chỉ dùng hàm filter thông thường:

ghci> filter (\x -> x < 4) [9,1,5,2,10,3]
[1,2,3]
Thật khá dễ. Bây giờ, ta hãy lập một vị từ sao cho, ngoài việc biểu diễn kết quảTrue hoặc False, còn đưa ra nội dung ghi chép những gì nó thực hiện được. Đương nhiên, ta sẽ dùng Monad Writer vào việc này:

keepSmall :: Int -> Writer [String] Bool
keepSmall x
    | x < 4 = do
        tell ["Keeping " ++ show x]
        return True
    | otherwise = do
        tell [show x ++ " is too large, throwing it away"]
        return False
Thay vì có “just” và trả về một Bool, hàm này trả về một Writer [String] Bool. Đó là một vị từ Monad. Nghe hay đấy nhỉ? Nếu như con số nhỏ hơn 4 thì máy báo rằng sẽ giữ số đó lại rồi return True.

Bây giờ hãy đưa kết quả thu được vào filterM cùng với một list. Bởi vị từ đang xét trả về một giá trị Writer, nên list thu được cũng sẽ là một giá trị Writer.

ghci> fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
[1,2,3]
Kiểm tra lại kết quả của giá trị Writer thu được, ta thấy mọi thứ đều ổn. Bây giờ, hãy in ra nội dung ghi chép và xem ta nhận được những gì nào:

ghci> mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
9 is too large, throwing it away
Keeping 1
5 is too large, throwing it away
Keeping 2
10 is too large, throwing it away
Keeping 3
Tuyệt. Như vậy chỉ bằng việc cung cấp một vị từ Monad cho filterM, ta đã có thể lọc một list trong khi vẫn tận dụng được ngữ cảnh Monad mà ta đã dùng.

Một mẹo rất hay trong Haskell là cách dùng filterM để thu được tập lũy thừa của một list (nếu ta tạm coi list là tập hợp). Với một tập hợp bất kì, tập lũy thừa của nó là một tập hợp chứa tất cả những tập con của tập hợp ban đầu. Như vậy nếu ta có một tập hợp chẳng hạn [1,2,3], thì tập lũy thừa của nó sẽ chứa những tập hợp sau:

[1,2,3]
[1,2]
[1,3]
[1]
[2,3]
[2]
[3]
[]
Nói cách khác, việc lấy một tập lũy thừa cũng như lấy tất cả những tổ hợp của việc giữ và vứt bỏ các phần tử thuộc một tập hợp cho trước. [2,3] cũng giống như tập hợp ban đầu, chỉ có điều là ta đã loại bỏ con số 1.

Để lập một hàm có nhiệm vụ trả về tập lũy thừa của một list cho trước, ta sẽ dựa vào sự không tất định. Ta lấy list [1,2,3] rồi xét phần tử thứ nhất, tức là 1, rồi tự hỏi: nên giữ lại hay bỏ nó đi? À, thực ra thì ta muốn làm cả hai việc. Như vậy, ta sẽ lọc một list và dùng một vị từ để vừa giữ lại, vừa bỏ đi từng phần tử một khỏi list, theo nghĩa không tất định. Sau đây là hàm powerset được lập ra:

powerset :: [a] -> [[a]]
powerset xs = filterM (\x -> [True, False]) xs
Đợi đã, phải nó không vậy? Đúng. Ta chọn cách bỏ và giữ từng phần tử một, bất kể đó là phần tử gì. Ta có một vị từ không tất định, vì vậy list thu được cũng sẽ là một giá trị không tất định và do vậy sẽ là một list chứa các list. Hãy thử hàm này xem:

ghci> powerset [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
Cần tư duy một chút để hiểu được kết quả trên, nhưng nếu bạn chỉ cần coi list như là giá trị không tất định với kết quả có thể là mọi thứ cùng lúc, thì sẽ dễ hơn.

FOLDM
Dạng Monad của foldl là foldM. Nếu bạn còn nhớ những phép gấp từ mục này, thì bạn đã biết rằng foldl nhận vào một hàm hai ngôi, một biến tích lũy khởi đầu và một list để gấp lại, từ phía trái bằng hàm đã cho, thành một giá trị. foldM cũng thực hiện điều tương tự, chỉ khác là nó nhận hàm hai ngôi với nhiệm vụ tạo ra một giá trị Monad rồi gấp list lại bằng hàm đó. Không ngạc nhiên gì khi biết rằng kết quả cũng có tính Monad. Kiểu của foldl là như sau:

foldl :: (a -> b -> a) -> a -> [b] -> a
Còn foldM có kiểu như sau:

foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
Giá trị mà hàm hai ngôi này trả về có tính Monad và vì vậy kết quả của toàn bộ phép gấp cũng có tính Monad. Ta hãy lấy tổng một list các số bằng phép gấp:

ghci> foldl (\acc x -> acc + x) 0 [2,8,3,1]
14
Biến tích lũy khởi đầu là 0 và rồi 2 được cộng thêm vào biến tích lũy, nên biến có giá trị mới bằng 2. 8 được cộng thêm vào biến tích lũy này khiến cho giá trị mới bằng 10 và cứ thế đến cuối cùng, và kết quả là biến tích lũy lúc đó.

Bây giờ sẽ ra sao nếu ta muốn tính tổng một list số nhưng thêm điều kiện là nếu có bất cứ số nào lớn hơn 9 có trong list thì toàn bộ quá trình tính toán bị thất bại? Sẽ hợp lý nếu ta dùng một hàm hai ngôi để kiểm tra xem liệu số đang xét có lớn hơn 9 hay không và nếu đúng, thì tính toán được cho là thất bại; còn nếu không, thì vui vẻ tiếp tục. Vì khả năng thất bại mới được bổ sung này, ta hãy làm cho hàm hai ngôi đang xét trả về một biến tích lũy Maybe thay vì kiểu thông thường. Sau đây là hàm hai ngôi:

binSmalls :: Int -> Int -> Maybe Int
binSmalls acc x
    | x > 9     = Nothing
    | otherwise = Just (acc + x)
Vì hàm hai ngôi đang xét bây giờ là một hàm Monad, ta không thể dùng nó với hàm foldl thông thường, mà phải dùng đến foldM, như sau:

ghci> foldM binSmalls 0 [2,8,3,1]
Just 14
ghci> foldM binSmalls 0 [2,11,3,1]
Nothing
Rất tốt! Vì có một số trong list lớn hơn 9, nên toàn bộ trở thành Nothing. Việc gấp với một hàm hai ngôi trả về một giá trị Writer cũng rất hay vì khi đó bạn ghi chép được tất cả những thứ gì mong muốn trong quá trình gấp.

LẬP NÊN MỘT CHIẾC MẤY TÍNH RPN AN TOÀN
i've found yellow!

Khi giải bài toán thiết lập máy tính RPN, ta đã lưu ý rằng nó luôn hoạt động tốt, miễn là dữ liệu đầu vào phải có nghĩa. Nhưng nếu có gì sai sót, thì toàn bộ chương trình sẽ đổ vỡ. Bây giờ khi ta đã biết cách lấy một đoạn mã ta có và biến nó trở thành Monad rồi, ta hãy thêm tính năng xử lý lỗi cho máy tính RPN hiện có, bằng cách tận dụng Monad Maybe.

Ta thiết lập máy tính RPN bằng cách lấy một chuỗi kí tự như "1 3 + 2 *", phá vỡ nó thành từng “từ” riêng lẻ như ["1","3","+","2","*"] rồi thực hiện gấp list này cùng với một ngăn xếp rỗng rồi dùng một hàm gấp hai ngôi để thêm các số vào ngăn xếp hoặc thao tác với những con số ở đỉnh ngăn xếp thông qua phép cộng, trừ, nhân, chia.

Đây là phần thân của hàm này:

import Data. list

solveRPN :: String -> Double
solveRPN = head . foldl foldingFunction [] . words
Ta đã biến đổi biểu thức thành một list các chuỗi kí tự, xử lý nó bằng hàm gấp và rồi nhận được một phần tử duy nhất trong ngăn xếp, ta trả về phần tử này làm kết quả. Sau đây là hàm gấp:

foldingFunction :: [Double] -> String -> [Double]
foldingFunction (x:y:ys) "*" = (x * y):ys
foldingFunction (x:y:ys) "+" = (x + y):ys
foldingFunction (x:y:ys) "-" = (y - x):ys
foldingFunction xs numberString = read numberString:xs
Biến tích lũy của phép gấp là một ngăn xếp, mà ta biểu diễn bằng một list các giá trị Double. Trong khi hàm gấp duyệt qua biểu thức RPN, nếu phần tử được xét là một toán tử, thì hàm này lấy hai phần tử ra khỏi đỉnh ngăn xếp, áp dụng toán tửu lên chúng rồi đặt kết quả trở lại vào ngăn xếp. Nếu phần tử được xét là một chuỗi kí tự biểu diễn cho một con số, thì hàm sẽ quy đổi chuỗi đó thành số rồi trả về một ngăn xếp mới giống ngăn xếp cũ, nhưng có thêm số vừa rồi được đẩy lên đỉnh ngăn xếp.

Trước hết, ta hãy làm cho hàm gấp có khả năng xử lý thât bại một cách đẹp mắt. Kiểu của hàm này sẽ thay đổi sang thành như sau:

foldingFunction :: [Double] -> String -> Maybe [Double]
Như vậy nó sẽ hoặc là trả về Just với một ngăn xếp mới hoặc sẽ thất bại với Nothing.

Hàm reads cũng giống như read, chỉ khác là nó trả về một list với một phần tử trong trường hợp đọc thành công. Nếu thất bại, không đọc được gì thì nó sẽ trả về một danh sach rỗng. Ngoại trừ việc trả về giá trị đã đọc, nó cũng trả về phần chuỗi không dùng đến. Ta sẽ nói rằng để hoạt động bình thường, hàm này luôn phải dùng đến toàn bộ dữ liệu đầu vào rồi chuyển thành một hàm readMaybe, để cho tiện. Sau đây là hàm này:

readMaybe :: (Read a) => String -> Maybe a
readMaybe st = case reads st of [(x,"")] -> Just x
                                _ -> Nothing
Hãy thử dùng nó:

ghci> readMaybe "1" :: Maybe Int
Just 1
ghci> readMaybe "GO TO HELL" :: Maybe Int
Nothing
Được rồi, có vẻ nó đã hoạt động. Vì vậy, hãy làm cho hàm gấp trong tay ta trở thành một hàm Monad mà có thể thất bại:

foldingFunction :: [Double] -> String -> Maybe [Double]
foldingFunction (x:y:ys) "*" = return ((x * y):ys)
foldingFunction (x:y:ys) "+" = return ((x + y):ys)
foldingFunction (x:y:ys) "-" = return ((y - x):ys)
foldingFunction xs numberString = liftM (:xs) (readMaybe numberString)
Ba trường hợp đầu cũng giống như trước đây, chỉ khác rằng ngăn xếp mới được bọc vào trong một Just (ở đây ta đã dùng return để làm việc này, nhưng cũng có thể viết Just). Trong trường hợp sau cùng, ta viết readMaybe numberString rồi ánh xạ (:xs) lên nó. Như vậy nếu ngăn xếp xs là [1.0,2.0] và readMaybe numberString có kết quả là Just 3.0, thì kết quả là Just [3.0,1.0,2.0]. Nếu readMaybe numberString cho kết quả là Nothing thì kết quả là Nothing. Ta hãy thử hàm gấp này:

ghci> foldingFunction [3,2] "*"
Just [6.0]
ghci> foldingFunction [3,2] "-"
Just [-1.0]
ghci> foldingFunction [] "*"
Nothing
ghci> foldingFunction [] "1"
Just [1.0]
ghci> foldingFunction [] "1 wawawawa"
Nothing
Dường như nó đã hoạt động đúng! Và bây giờ là lúc dành cho hàm solveRPN mới cải tiến. Xin quý vị hãy xem!

import Data. list

solveRPN :: String -> Maybe Double
solveRPN st = do
    [result] <- foldM foldingFunction [] (words st)
    return result
Cũng như trước đây, ta lấy chuỗi kí tự rồi biến nó thành một list các từ. Sau đó, ta thực hiện phép gấp, bắt đầu với một ngăn xếp rỗng, chỉ khác là thay vì thực hiện một foldl thông thường, ta thực hiện foldM. Kết quả của việc dùng foldM sẽ là một giá trị Maybe có chứa một list (chính là ngăn xếp cuối cùng thu được) và list đó phải có đúng một giá trị. Ta dùng một biểu thức do để lấy giá trị đó rồi gọi nó là result. Trong trường hợp foldM trả về một Nothing, tất cả sẽ thành Nothing, vì đó chính là cách hoạt động của Maybe. Cũng lưu ý rằng ta khớp mẫu trong biểu thức do, vì vậy nếu list có nhiều giá trị hoặc không có giá trị nào, thì việc khớp mẫu sẽ thất bại và tạo ra một giá trị Nothing. Ở dòng lệnh cuối cùng, ta chỉ việc viết return result để biểu diễn kết quả của phép tính RPN làm kết quả cuối cùng của giá trị Maybe.

Ta hãy thử nó:

ghci> solveRPN "1 2 * 4 +"
Just 6.0
ghci> solveRPN "1 2 * 4 + 5 *"
Just 30.0
ghci> solveRPN "1 2 * 4"
Nothing
ghci> solveRPN "1 8 wharglbllargh"
Nothing
Sự thất bại đầu tiên xảy ra vì ngăn xếp cuối cùng không phải là một list chỉ chứa một phần tử, dẫn đến việc khớp mẫu trong biểu thức do bị thất bại. Sự thất bại thứ hai xảy ra vì readMaybe trả về một Nothing.

HỢP CÁC HÀM Monad
Khi học về các định luật Monad, ta đã nói rằng hàm <=< đơn giản là giống như phép hợp các hàm, chỉ khác là thay vì những hàm thông thường như a -> b, nó làm việc với các hàm Monad như a -> m b. Chẳng hạn:

ghci> let f = (+1) . (*100)
ghci> f 4
401
ghci> let g = (\x -> return (x+1)) <=< (\x -> return (x*100))
ghci> Just 4 >>= g
Just 401
Ở ví dụ này đầu tiên là ta hợp hai hàm thường, rồi áp dụng hàm thu được đối với 4, sau đó hợp hai hàm Monad rồi đưa Just 4 vào hàm kết quả bằng >>=.

Nếu ta có một loạt các hàm trong một list, ta có thể hợp tất cả chúng thành một hàm lớn bằng cách đơn giản là dùng id làm biến tích lũy ban đầu và hàm . đóng vai trò của hàm hai ngôi. Sau đây là một ví dụ:

ghci> let f = foldr (.) id [(+1),(*100),(+1)]
ghci> f 1
201
Hàm f nhận một con số rồi cộng 1 vào nó, đem nhân kết quả với 100 rồi cộng 1 vào kết quả thu được. Dù sao đi nữa, ta cũng có thể hợp các hàm Monad theo cách này, chỉ khác là thay vì phép hợp thông thường, ta dùng <=< và thay vì id, ta dùng return. Ta không cần phải dùng foldM thay cho foldr hay những gì như vậy, vì hàm <=< đảm bảo rằng phép hợp được tiến hành theo cách Monad.

Khi bắt đầu làm quen với list Monad trong chương trước, ta đã dùng nó để chỉ ra cách một quân Mã đi từ ô này sang ô khác trên bàn cờ sau ba nước. Ta đã có một hàm tên là moveKnight nhận vào ô xuất phát của quân Mã trên bàn cờ rồi trả về tất cả những nước đi nó có thể thực hiện được. Tiếp theo, để phát sinh tất cả những vị trí quân Mã có thể đứng sau ba nước, ta đã lập nên những hàm sau:

in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight
Và để kiểm tra xem nó có thể đi từ ô start đến ô end sau ba nước hay không, ta làm như sau:

canReachIn3 :: KnightPos -> KnightPos -> Bool
canReachIn3 start end = end `elem` in3 start
Bằng cách dùng hàm hợp Monad, ta có thể lập nên một hàm như in3, nhưng thay vì phát sinh tất cả những ô mà quân Mã có thể đến sau ba nước, thì giải quyết trường hợp với số nước đi bất kì. Nếu nhìn vào in3, ta thấy rằng mình đã sử dụng moveKnight ba lần và trong mỗi lần đã sử dụng >>= để đưa vào hàm này tất cả những vị trí quân Mã có thể đứng lúc trước. Như vậy, bây giờ ta hãy làm cho hàm này tổng quát hơn. Sau đây là cách làm:

import Data. list

inMany :: Int -> KnightPos -> [KnightPos]
inMany x start = return start >>= foldr (<=<) return (replicate x moveKnight)
Trước tiên, ta dùng replicate để lập nên list có chứa x bản sao của hàm moveKnight. Sau đó, ta hợp, theo cách Monad, tất cả những hàm này làm một; điều này cho ta một hàm nhận vào ô xuất phát và di chuyển quân Mã một cách không tất định x lần. Tiếp theo, ta chỉ việc biến ô xuất phát thành một list một phần tử bằng lệnh return rồi đưa nó vào hàm.

Bây giờ, ta cũng có thể thay đổi hàm canReachIn3 để cho được tổng quát hơn:

canReachIn :: Int -> KnightPos -> KnightPos -> Bool
canReachIn x start end = end `elem` inMany x start

Lập ra các Monad
kewl

Trong mục này, ta sẽ xét một ví dụ về cách tạo ra một kiểu dữ liệu, nhận diện nó như một mand rồi gán cho thực thể Monad phù hợp. Ta không thường xuyên tạo lập một Monad chỉ để cho có; mà với mục đích để mô hình hóa một khía cạnh của vấn đề rồi sau đó nếu thấy rằng kiểu dữ liệu được xét biểu diễn cho một giá trị kèm ngữ cảnh và có thể đóng vai trò như Monad, thì gán cho nó một thực thể Monad.

Như đã thấy, các list được dùng để biểu diễn cho giá trị không tất định. Một list như [3,5,9] có thể được coi là một giá trị không tất định mà bản thân nó không tự quyết được sẽ là gì. Khi ta đưa một list vào một hàm bằng >>=, chương trình sẽ thực hiện tất cả những lựa chọn có thể cho việc lấy một phần tử khỏi list rồi áp dụng hàm lên nó, sau đó biểu diễn những kết quả đó cũng dưới dạng list.

Nếu ta coi list [3,5,9] như những con số 3, 5 và 9 xuất hiện cùng lúc, ta có thể nhận thấy rằng không có thông tin gì về xác suất xuất hiện của chúng. Sẽ ra sao nếu ta muốn mô phỏng một giá trị không tất định nhưng [3,5,9], nhưng muốn chỉ định rằng 3 có 50% khả năng xuát hiện còn 5 và 9, mỗi số có 25% khả năng xuất hiện? Ta hãy thử làm điều này!

Giả sử rằng mỗi phần tử trong list đều kèm theo một giá trị khác, một con số xác suất xuất hiện. Thế thì việc biểu diễn nó như sau là hợp lý:

[(3,0.5),(5,0.25),(9,0.25)]
Về mặt toán học, xác suất không thường được biểu diễn dưới dạng số phần trăm, mà là những số thực từ 0 đến 1. Số 0 nghĩa là không có cơ hội để điều gì có thể xảy ra, còn 1 nghĩa là chắc chắn điều đó sẽ xảy đến. Các số với dấu chấm động trong quá trình tính toán sẽ nhanh chóng mất đi độ chính xác, vì vậy Haskell cho ta một kiểu dữ diệu riêng cho các phân số mà độ chính xác của chúng không bị mất đi. Kiểu dữ liệu này có tên Rational và nó tồn tại trong Data.Ratio. Để tạo nên một Rational, ta viết nó dưới dạng như một phân số. Tử số và mẫu số được phân cách bởi một dấu %. Sau đây là vài ví dụ:

ghci> 1%4
1 % 4
ghci> 1%2 + 1%2
1 % 1
ghci> 1%3 + 5%4
19 % 12
Dòng đầu tiên đơn giản chỉ là một phần tư. Ở dòng thứ hai, ta cộng hai nửa lại để thu được số một, và dòng thứ ba ta cộng một phần ba với năm phần tư để được 19 phần 12. Vậy ta hãy vứt bỏ các dấu phẩy động đi và dùng Rational để biểu diễn xác suất:

ghci> [(3,1%2),(5,1%4),(9,1%4)]
[(3,1 % 2),(5,1 % 4),(9,1 % 4)]
Được rồi, như vậy là 3 có khả năng xuất hiện một lần trong hai lượt, còn 5 và 9 sẽ xuất hiện một lần trong khoảng bốn lượt. Rất gọn gàng.

Ta chọn lấy list rồi bổ sung thêm ngữ cảnh cho chúng, như vậy nó sẽ biểu thị các giá trị kèm với ngữ cảnh. Trước khi đi tiếp, ta hãy gói những thứ này vào trong một newtype vì có điều gì đó mách bảo tôi rằng chúng ta sẽ cần lập nên một số thực thể.

import Data.Ratio

newtype Prob a = Prob { getProb :: [(a,Rational)] } deriving Show
Được rồi. Đây là một functor à? A hèm, list là một functor, vì vậy thứ này có lẽ cũng là một functor, vì ta vừa mới bổ sung thêm gì đó vào list. Khi ánh xạ một hàm lên một list, ta áp dụng nó cho từng phần tử. Ở đây, ta cũng sẽ áp dụng nó cho từng phần tử, nhưng có điều là giữ nguyên các xác suất. Ta hãy lập một thực thể:

instance Functor Prob where
    fmap f (Prob xs) = Prob $ map (\(x,p) -> (f x,p)) xs
Ta gỡ vỏ bọc khỏi newtype bằng cách khớp mẫu, áp dụng hàm f cho các giá trị trong khi vẫn giữ nguyên các xác suất rồi lại bọc nó trở lại. Hãy thử xem liệu nó có hoạt động không:

ghci> fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])
Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}
Một điều khác cần lưu ý là những xác suất luôn phải có tổng bằng 1. Nếu sự việc chỉ có ngần ấy khả năng xảy ra, thì sẽ chẳng có lý gì mà những xác suất của chúng cộng lại không bằng 1. Có lẽ phải đến một thế giới khác mới thấy được đồng xu nào lật ngửa 75% mà lại sấp 50% trong tổng số các lần gieo.

Bây giờ câu hỏi lớn là, liệu đây có phải là Monad không? Ta đã biết list là một Monad rồi, thì thứ này lý ra cũng phải là một Monad. Trước hết, hãy nghĩ về return. Nó hoạt động ra sao với các list? Nó lấy một giá trị rồi đặt vào list một phần tử. Ở đây thì sao? Ồ, vì nó phải là một ngữ cảnh tối thiểu mặc định, nên nó cũng là một list một phần tử. Thế còn về xác suất? Ừm, return x phải tạo ra một giá trị Monad sao cho luôn biểu thị x làm kết quả, cho nên xác suất không có lý gì mà bằng 0 được. Nếu nó luôn phải biểu thị giá trị làm kết quả, thì xác suất phải là 1!

Thế còn về >>=? Có vẻ rất mẹo mực, vì vậy ta hãy tận dụng thông tin là đối với các Monad, m >>= f luôn bằng join (fmap f m), rồi nghĩ cách duỗi thẳng một list xác suất chứa những list xác suất khác. Chẳng hạn, ta hãy xét list trong đó có 25% khả năng xuất hiện đúng một chữ 'a' hoặc 'b'. Cả hai 'a' và 'b' đều cùng khả năng xuất hiện. Ngoài ra cũng có 75% khả năng là có đúng một chữ 'c' hoặc 'd' xuất hiện. 'c' và 'd' cũng có cùng khả năng có mặt. Sau đây là một hình ảnh về list xác suất để mô phỏng cho trường hợp này:

probs

Đâu là các khả năng xuất hiện của từng chữ cái này? Nếu ta phải phân chia những thứ ở đây thành bốn hộp, mỗi hộp có một xác suất, thì những xác suất đó sẽ bằng bao nhiêu? Để tính được các xác suất này, việc ta cần làm chỉ là đem nhân từng xác suất với tất cả những xác suất mà nó bao gồm. 'a' sẽ xảy ra một lần trong số tám lượt, và 'b' cũng vậy, vì nếu ta nhân một nửa với một phần tư thì sẽ được một phần tám. 'c' sẽ xảy ra ba lần trong tám lượt vì ba phần tư nhân với một nửa thì bằng ba phần tám. 'd' cũng sẽ xảy ra ba lần trong tám lượt. Nếu ta cộng tất cả xác suất lại thì sẽ được kết quả bằng một.

Sau đây là tình huống hiện giờ được biểu diễn dưới dạng list xác suất:

thisSituation :: Prob (Prob Char)
thisSituation = Prob
    [( Prob [('a',1%2),('b',1%2)] , 1%4 )
    ,( Prob [('c',1%2),('d',1%2)] , 3%4)
    ]
Lưu ý rằng kiểu của nó là Prob (Prob Char). Vậy bây giờ, khi đã hình dung được cách duỗi thẳng một list xác suất lồng ghép rồi, thì tất cả những gì ta cần làm là viết ra mã lệnh rồi sau đó ta có thể dùng >>= đơn giản như là join (fmap f m) và ta sẽ có trong tay một Monad! Sau đây là flatten; ta sẽ dùng tên gọi này vì cái tên join đã bị chọn trước rồi:

flatten :: Prob (Prob a) -> Prob a
flatten (Prob xs) = Prob $ concat $ map multAll xs
    where multAll (Prob innerxs,p) = map (\(x,r) -> (x,p*r)) innerxs
Hàm multAll nhận một bộ các list xác suất và một xác suất p đi kèm theo rồi nhân mỗi xác suất bên trong với p, trả về kết quả là một list các cặp phần tử kèm theo xác suất. Ta ánh xạ multAll lên từng cặp trong list xác suất lồng ghép rồi sau đó chỉ việc duỗi thẳng list lồng ghép thu được.

Bây giờ khi đã sẵn có tất cả những thứ cần thiết, ta có thể viết nên thực thể Monad!

instance Monad Prob where
    return x = Prob [(x,1%1)]
    m >>= f = flatten (fmap f m)
    fail _ = Prob []
ride em cowboy

Vì ta đã làm tất cả phần việc nặng nhọc rồi, nên thực thể sẽ rất đơn giản. Ta cũng đã định nghĩa hàm fail, vốn giống như ở trường hợp list, vì vậy nếu có một thất bại trong việc khớp mẫu ở một biểu thức do, thì sẽ có thất bại xảy ra trong ngữ cảnh của list xác suất.

Một việc cũng quan trọng là kiểm tra xem liệu Monad mới lập nên có thỏa mãn các định luật Monad hay không. Định luật đầu tiên phát biểu rằng return x >>= f phải bằng với f x. Để chứng minh chặt chẽ ở đây thì rất nhàm chán, nhưng ta có thể thấy rằng nếu đặt một giá trị vào trong một ngữ cảnh mặc định bằng return vào sau đó fmap một hàm lên nó rồi duỗi thẳng list xác suất thu được, thì mỗi xác suất thu được từ hàm sẽ được nhân lên với 1%1 xác suất mà ta đã lập bằng return, vì vậy sẽ không ảnh hưởng đến ngữ cảnh. Lý do mà m >>= return chỉ bằng với m thật đơn giản. Định luật thứ ba phát biểu rằng f <=< (g <=< h) phải giống như (f <=< g) <=< h. Điều này cũng thỏa mãn, vì định luật thỏa mãn với những Monad list tạo nên cơ sở của Monad xác suất và vì phép nhân có tính kết hợp. 1%2 * (1%3
* 1%5) bằng với (1%2 * 1%3) * 1%5.

Bây giờ khi đã có Monad, ta có thể làm gì với nó? À, nó có thể giúp ta tính toán với những xác suất. Ta có thể coi những biến cố xác suất như các giá trị kèm theo ngữ cảnh và Monad xác suất sẽ đảm bảo rằng những xác suất này sẽ được phản ánh trong xác suất ở kết quả cuối cùng.

Chẳng hạn ta có hai đồng xu đều đặn và một đồng xu được chế tạo gian lận mà khi tung sẽ sấp đến chín lần và ngửa một lần trong số mười lượt. Nếu ta tung cả hai đồng xu một lúc, thì khả năng để chúng cùng sấp là bao nhiêu? Trước hết, hãy tính giá trị xác suất của đồng xu thường và đồng xu gian lận:

data Coin = Heads | Tails deriving (Show, Eq)

coin :: Prob Coin
coin = Prob [(Heads,1%2),(Tails,1%2)]

loadedCoin :: Prob Coin
loadedCoin = Prob [(Heads,1%10),(Tails,9%10)]
Và cuối cùng là hành động gieo đồng xu:

import Data. list (all)

flipThree :: Prob Bool
flipThree = do
    a <- coin
    b <- coin
    c <- loadedCoin
    return (all (==Tails) [a,b,c])
Chạy thử mã lệnh này, ta thấy rằng khả năng cả ba đồng xu cùng sấp không lớn như đã tưởng tượng, dù rằng đã có cả một đồng xu gian:

ghci> getProb flipThree
[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),
 (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
Cả ba đồng xu này sẽ đều sấp chín lần trong số 40 lượt, tức là ít hơn 25%. Ta thấy rằng Monad ở đây không biết cách cộng lại làm một tất cả những kết quả False trong những có đồng xu ngửa. Điều này cũng không quan trọng lắm, vì việc viết một hàm để thu những trường hợp như vậy làm một thì khá dễ dàng; đây chính là bài tập dành cho độc giả (là bạn đấy!)

Trong mục này, ta đã đi từ việc đặt một câu hỏi (điều gì sẽ xảy ra nếu list cũng mang thông tin về xác suất?) đến việc lập một kiểu dữ liệu, tiếp nhận một Monad, rồi cuối cùng là lập một thực thể và thao tác với nó. Tôi nghĩ rằng điều này thật là hấp dẫn! Đến giờ, ta hẳn đã nắm vững được Monad rồi.




[Haskell #17: Monad (kế)](https://vutuanhai237.github.io/haskell/2021/05/12/haskell-17.html)

<p style="text-align: right">Tác giả</p>

<p style="text-align: right;">
Vũ Tuấn Hải - Monadotory
</p>