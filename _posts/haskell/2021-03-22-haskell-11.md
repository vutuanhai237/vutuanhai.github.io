---
layout: post
title: "Haskell #10: Functor"
categories: haskell
link: https://vutuanhai237.github.io/haskell/2021/03/22/haskell-11.html
---

[Haskell #10: Cấu trúc dữ liệu đệ quy & Typeclass & YesNo](https://vutuanhai237.github.io/haskell/2021/03/22/haskell-10.html)

Class Functor
Đến giờ, ta đã gặp nhiều class trong thư viện chuẩn. Ta đã nghịch với Ord, với Eq, với Show, với Read. Và bây giờ, ta xét đến class Functor, về cơ bản là những thứ có thể được map. Có lẽ bạn sẽ nghĩ về list, vì map trên list là “tuyệt chiêu” của Haskell. Và bạn đã đúng, list thuộc về class Functor.
Để tìm hiểu về class Functor thì còn gì hay hơn là xem nó được thiết code thế nào? Ta hãy thử ghé xem qua.
class Functor f where
    fmap :: (a -> b) -> f a -> f b
 
Được rồi. Ta thấy rằng nó định nghĩa một hàm, fmap, và không cho ta bất kì cách thực thi mặc định nào cho nó. Kiểu fmap rất thú vị. Trong số các định nghĩa class ta gặp đến giờ, biến kiểu đóng vai trò là kiểu trong class luôn là kiểu cụ thể, như a trong (==) :: (Eq a) => a -> a -> Bool. Nhưng giờ đây, f không phải là kiểu cụ thể (như Int, Bool hoặc Maybe String), mà là một type constructor nhận vào một tham số kiểu. Một ví dụ nhanh chóng để ôn lại: Maybe Int là kiểu cụ thể, còn Maybe là type constructor chỉ nhận vào kiểu với vai trò tham số. Dù sao thì ta thấy rằng fmap nhận vào một hàm từ kiểu này sang kiểu khác và functor áp dụng với kiểu rồi trả về functor được áp dụng với kiểu khác.
Đừng lo nếu diều này nghe có vẻ dễ nhầm lẫn. Tất cả sẽ sớm được sáng tỏ khi điểm qua một vài ví dụ. Hừm, khai báo vừa rồi với fmap gợi cho tôi nhớ về điều gì đó. Type signature của map là map :: (a -> b) -> [a] -> [b], trong trường hợp bạn không biết.
A, hay đấy! Nó nhận vào hàm từ chuyển từ kiểu này sang kiểu khác và list chứa kiểu này rồi trả về list chứa kiểu khác. Bạn ơi, tôi nghĩ rằng ta đã có một functor! Thực ra, map chỉ là fmap nhưng chỉ làm việc trên list. Đây là cách mà list là thể hiện của Functor.
instance Functor [] where
    fmap = map
Như vậy đó! Lưu ý rằng ta không code instance Functor [a] where, vì từ fmap :: (a -> b) -> f a -> f b, ta thấy được rằng f phải là type constructor, nhận vào kiểu. [a] sẵn là một kiểu cụ thể (list kiểu a), còn [] là một type constructor nhận vào kiểu và tạo ra kiểu cụ thể như [Int], [String] hoặc thậm chí [[String]].
Bởi vì với list, fmap chỉ đơn thuần là map nên ta nhận kết quả hệt như vậy khi dùng chúng với list.
map :: (a -> b) -> [a] -> [b]
ghci> fmap (*2) [1..3]
[2,4,6]
ghci> map (*2) [1..3]
[2,4,6]
Điều gì sẽ xảy ra khi ta map hoặc fmap lên list rỗng? Ồ, dĩ nhiên là thu được list rỗng. Chỉ có điều list rỗng kiểu [a] biến thành list rỗng kiểu [b].
Những kiểu dữ liệu nào đóng vai trò như cái hộp thì có thể thành functor. Bạn có thể hình dung list là một cái hộp có vô vàn những ngăn nhỏ và chúng có thể đều trống rỗng, hoặc là chỉ có một ngăn đầy, hoặc là nhiều ngăn đầy. Như vậy, có những thuộc tinh nào khác ở một cái hộp như vậy? Một thuộc tính là kiểu Maybe a. Ở một chừng mực nào đó, cũng giống như một cái hộp có thể không chứa gì, tương ứng với giá trị Nothing, hoặc chỉ chứa "HAHA", tương ứng với giá trị Just "HAHA". Sau đây là cách mà Maybe đóng vai trò functor.
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
Một lần nữa, hãy chú ý cách ta code instance Functor Maybe where thay vì instance Functor (Maybe m) where, cũng như ta đã làm với Maybe và YesNo. Functor cần type constructor, constructor nhận vào một kiểu chứ không phải kiểu cụ thể. Nếu bạn thử tưởng tượng việc thay thế f với Maybe thì fmap sẽ là (a -> b) -> Maybe a -> Maybe b; và cách này có vẻ ổn. Nhưng nếu bạn thay thế f bằng (Maybe m) thì dường như nó sẽ là (a -> b) -> Maybe m a -> Maybe m b, tức là chẳng có ý nghĩa gì bởi Maybe chỉ nhận duy nhất một tham số kiểu.
Dù sao đi nữa, code fmap  khá đơn giản. Nếu nó là rỗng: Nothing, thì chỉ cần trả về Nothing. Nếu ta map trên hộp rỗng thì ta thu được hộp rỗng. Có lý. Cũng như ta map trên list rỗng, ta sẽ nhận được list rỗng. Nếu nó không rỗng, mà là giá trị đơn lẻ đặt trong Just, thì ta áp dụng hàm đối với nội dung của Just.
ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")
Just "Something serious. HEY GUYS IM INSIDE THE JUST"
ghci> fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing
Nothing
ghci> fmap (*2) (Just 200)
Just 400
ghci> fmap (*2) Nothing
Nothing
Một thứ khác có thể được map và là thể hiện Functor là kiểu Tree a mà ta đã code. Nó có thể được hình dung như một cái hộp (theo khía cạnh có thể giữ nhiều giá trị hoặc không giữ thứ gì) và type constructor Tree nhận vào đúng một tham số kiểu. Nếu bạn xét fmap như thể nó là một hàm để dành riêng cho Tree thì type signature của nó sẽ là (a -> b) -> Tree a -> Tree b. Ta sẽ dùng đệ quy đối với kiểu dữ liệu này. Việc map trên cây rỗng sẽ tạo ra cây rỗng. Map trên cây không rỗng sẽ tạo ra một cây trong đó hàm sẽ được áp dụng cho gốc, còn cây con trái và cây con phải vẫn là những cây con trước đây, chỉ khác là sẽ được chúng sẽ được map.
instance Functor Tree where
    fmap f EmptyTree = EmptyTree
    fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)
ghci> fmap (*2) EmptyTree
EmptyTree
ghci> fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])
Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree
Hay thật! Thế còn Either a b thì sao? Có thể cho nó thành functor được không? Class Functor cần một type constructor chỉ nhận vào một tham số kiểu nhưng Either lại nhận hai tham số. Hừm! Tôi biết rồi, chúng ta sẽ áp dụng Either từng phần bằng cách chỉ cấp cho nó một tham số để nó còn một tham số tự do. Đây là cách làm cho Either a là functor trong thư viện chuẩn:
instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
Nào nào, chúng ta đã làm gì ở đây vậy? Bạn có thể thấy cách làm cho Either a thành một thể hiện thay vì chỉ là Either. Đó là vì Either a là một type constructor nhận vào một tham số, trong khi Either thì nhận vào hai tham số. Nếu fmap được dành riêng cho Either a thì type signature đã là (b -> c) -> Either a b -> Either a c vì như vậy thì gống với (b -> c) -> (Either a) b -> (Either a) c. Trong đoạn code trên, ta đã map trong trường hợp có type constructor là Right, nhưng lại không map trong trường hợp Left. Tại sao vậy? Nếu nhìn trở lại cách định nghĩa Either a b, ta sẽ thấy nó có dạng:
data Either a b = Left a | Right b
Như vậy, nếu ta muốn map một hàm lên cả hai vế, thì a và b phải có cùng kiểu. Ý của tôi là nếu ta thử map một hàm có nhận và trả về string, trong khi b là string mà a lại là Num thì sẽ không có tác dụng. Hơn nữa, từ việc thấy được kiểu của fmap sẽ là gì khi nó chỉ hoạt động với các giá trị Either, ta thấy rằng tham số thứ nhất phải giữ nguyên còn tham số thứ hai thay đổi được; và tham số thứ nhất thực tế là constructor value Left.
Điều này rất hợp với cách so sánh “cái hộp” nếu ta hình dung phần Left có dạng như một hộp rỗng chứa thông báo lỗi ghi bên cạnh cho ta biết tại sao nó lại rỗng.
Map trong Data.Map cũng có thể thành functor vì chúng giữ giá trị (hoặc không giữ thứ gì!). Trong trường hợp Map k v, fmap sẽ map một hàm v -> v' trên phép map kiểu Map k v rồi trả về map kiểu Map k v'.
Lưu ý rằng dấu ' không có ý nghĩa gì đặc biệt đối với kiểu, tương tự như khi ta đặt tên các giá trị. Dấu này thường dùng để chỉ những thứ gần giống nhau, chỉ thay đổi chút ít.
Hãy cố gắng tự hình dung xem bằng cách nào mà ta có thể làm cho Map k trở thành thể hiện của Functor!
Với class Functor, ta đã thấy bằng cách nào mà các class có hành vi cấp cao khá hay. Ta cũng đã thực hành thêm một chút với các kiểu dữ liệu áp dụng từng phần và với cách tạo thể hiện. Trong chương sau, ta sẽ xét đến vài định luật áp dụng cho functor.
Còn một điều nữa! Functor cần tuân theo một số định luật để chúng được phép có những thuộc tính mà ta có thể dựa vào mà không phải nghĩ nhiều. Nếu dùng fmap (+1) đối với list [1,2,3,4], ta sẽ dự tính kết quả là [2,3,4,5] chứ không phải ngược lại, [5,4,3,2]. Nếu ta dùng fmap (\a -> a) (hàm đồng nhất, trả về đúng các tham số nhận vào) đối với một list nào đó, ta sẽ dự định nhận về đúng list đó. Chẳng hạn, nếu ta dùng fmap đối với một cây trong đó cây con trái chỉ có những phần tử nhỏ hơn gốc và cây con phải chỉ có những phần tử lớn hơn gốc đó thì có thể sẽ tạo nên cây mới nhưng tính chất này không đảm bảo nữa. Trong chương sau ta sẽ đề cập chi tiết đến các định luật áp dụng cho functor.
Dạng và kiểu nào đó
 
Type constructor nhận vào tham số là kiểu khác rồi tạo ra kiểu cụ thể. Điều này làm tôi nhớ đến các hàm, chúng nhận vào tham số là giá trị để tạo ra giá trị. Ta đã thấy type constructor có thể áp dụng từng phần (Either String là một kiểu, nó nhận vào một kiểu và tạo ra kiểu cụ thể, như Either String Int), giống như hàm. Điều đó thật hay. Trong mục này, ta sẽ định nghĩa cách áp dụng kiểu cho type constructor, cũng như ta xét định nghĩa cách áp dụng hàm bằng khai báo kiểu. Bạn không cần phải đọc mục này mới tiếp tục chinh phục được Haskell và nếu bạn không hiểu nó thì đừng lo. Tuy nhiên, nắm được vấn đề này sẽ cho bạn hiểu biết tường tận về hệ thống kiểu.
Những giá trị như 3, "YEAH" hoặc takeWhile (các hàm cũng là giá trị, vì ta có thể truyền chúng thoải mái) mỗi cái đều có kiểu riêng. Kiểu là nhãn mà mỗi giá trị mang theo để dựa vào đó ta có thể suy luận về giá trị của chúng. Nhưng bản thân kiểu lại còn có nhãn của riêng chúng, gọi là dạng (kind). Dạng thì ít nhiều giống kiểu của kiểu. Điều này nghe hơi kì quặc và dễ gây nhầm lẫn, song thực ra đó là một khái niệm rất hay.
Dạng là gì và chúng dùng được vào việc gì? À, ta hãy xét dạng của một kiểu bằng cách dùng lệnh :k trong GHCI.
ghci> :k Int
Int :: *
Một dấu sao ư? Kì thật. Nó nghĩa là gì? Dấu * nghĩa là kiểu là kiểu cụ thể. Một kiểu cụ thể là kiểu không nhận bất kì tham số kiểu nào và giá trị chỉ có thể có kiểu nằm trong kiểu cụ thể. Nếu tôi buộc phải đọc hẳn dấu * ra (việc mà đến giờ tôi chưa làm), tôi sẽ đọc là sao hoặc đơn giản chỉ là kiểu.
Được rồi, bây giờ hãy xem dạng của Maybe là gì.
ghci> :k Maybe
Maybe :: * -> *
Type constructor Maybe nhận vào kiểu cụ thể (chẳng hạn, Int) rồi trả về kiểu cụ thể, chẳng hạn Maybe Int. Và đó chính là điều mà dạng cho ta biết. Cũng như Int -> Int  là hàm nhận vào một Int và trả về một Int, * -> * có nghĩa là type constructor nhận vào và trả về kiểu cụ thể. Ta hãy áp dụng tham số kiểu cho Maybe và để xem dạng của kiểu đó là gì.
ghci> :k Maybe Int
Maybe Int :: *
Đúng như tôi dự đoán! Chúng ta áp dụng tham số kiểu cho Maybe và thu lại kiểu cụ thể (đó là điều mà * -> * muốn nó). Một cách so sánh (mặc dù không tương đương, vì kiểu và dạng là khác nhau) với điều này là nếu ta code :t isUpper và :t isUpper 'A'. isUpper có kiểu là Char -> Bool và isUpper 'A' có kiểu là Bool, vì giá trị của nó về cơ bản là True. Tuy vậy cả hai kiểu trên đều có dạng là *.
Ta đã dùng :k đối với một kiểu để thu được dạng của nó, cũng như khi ta dùng :t đối với giá trị để thu được kiểu. Như đã nói, kiểu là nhãn gắn lên giá trị còn dạng là nhãn gắn lên kiểu và có sự tương đồng giữa hai thứ.
Ta hãy xem một dạng khác.
ghci> :k Either
Either :: * -> * -> *
À ha, điều này cho ta biết Either nhận vào hai kiểu cụ thể làm tham số kiểu và tạo ra một kiểu cụ thể. Nó cũng trông giống như khai báo kiểu của một hàm nhận vào hai giá trị và trả về một thứ gì đó. Type constructor được curry (cũng như đối với hàm), vì vậy ta có thể áp dụng từng phần.
ghci> :k Either String
Either String :: * -> *
ghci> :k Either String Int
Either String Int :: *
Khi ta muốn làm cho Either thuộc về class Functor, ta phải áp dụng từng phần vì Functor muốn kiểu chỉ nhận một tham số trong khi Either thì nhận hai. Nói cách khác, Functor muốn dạng * -> * và vì vậy ta phải áp dụng Either từng phần để thu được kiểu có dạng * -> * thay vì kiểu ban đầu của nó, * -> * -> *. Nếu ta nhìn vào định nghĩa của Functor lần nữa
class Functor f where 
    fmap :: (a -> b) -> f a -> f b
có thể thấy rằng biến kiểu f được dùng như là kiểu nhận vào kiểu cụ thể và tạo ra kiểu cụ thể. Ta biết rằng nó phải tạo ra kiểu cụ thể vì nó được dùng làm kiểu của giá trị trong hàm. Và từ đó, ta có thể suy diễn rằng những kiểu nào muốn là thể hiện với Functor  phải có dạng * -> *.
Bây giờ, ta hãy code một kiểu linh tinh. Hãy nhìn vào class sau, mà tôi sắp chuẩn bị code:
class Tofu t where
    tofu :: j a -> t a j
Chà, trông có vẻ lạ. Bằng cách nào mà ta có thể tạo ra một kiểu là thể hiện của class kì lạ này? À, hãy nhìn xem dạng của nó phải là gì. Bởi j a được dùng làm kiểu của một giá trị mà hàm tofu nhận vào làm tham số, nên j a phải có dạng là *. Ta giả sử a có dạng * và từ đó ta có thể suy luận rằng j phải có dạng * -> *. Ta thấy rằng t cũng phải tạo ra giá trị cụ thể và nó phải nhận hai kiểu. Đồng thời biết rằng a có dạng * và j có dạng * -> *, suy ra t phải có dạng * -> (* -> *) -> *. Vì vậy nó nhận một kiểu cụ thể (a), một type constructor nhận vào một kiểu cụ thể (j) rồi tạo ra một kiểu cụ thể. Ôi.
Được rồi, giờ ta hãy tạo một kiểu có dạng là * -> (* -> *) -> *. Sau đây là một cách giải.
data Frank a b  = Frank {frankField :: b a} deriving (Show)
Bằng cách nào mà ta biết được rằng kiểu này có dạng * -> (* -> *) - > *? À, các trường trong kiểu trừu tượng (ADT) sinh ra là để giữ các giá trị, vì vậy hiển nhiên là chúng phải có dạng *. Ta giả sử a có dạng *, điều này có nghĩa là b nhận vào một tham số kiểu và vì vậy dạng của nó là * -> *. Bây giờ khi đã biết dạng của cả hai a và b, và bởi vì chúng là các tham số cho Frank, ta thấy rằng Frank có dạng * -> (* -> *) -> * Dấu * thứ nhất biểu diễn cho a còn (* -> *) biểu diễn cho b. Ta hãy tạo một số giá trị Frank rồi kiểm tra kiểu của chúng.
ghci> :t Frank {frankField = Just "HAHA"}
Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe
ghci> :t Frank {frankField = Node 'a' EmptyTree EmptyTree}
Frank {frankField = Node 'a' EmptyTree EmptyTree} :: Frank Char Tree
ghci> :t Frank {frankField = "YES"}
Frank {frankField = "YES"} :: Frank Char []
Hừm. Bởi vì frankField có kiểu là a b, nên những giá trị của nó phải có kiểu cũng với hình thức tương tự. Vì vậy chúng có thể là Just "HAHA", vốn có kiểu Maybe [Char] hoặc có thể có giá trị ['Y','E','S'], vốn có kiểu [Char] (còn nếu ta dùng kiểu list thì sẽ là List[Char]). Và ta thấy rằng kiểu Frank tương ứng với dạng của Frank. [Char] có dạng là * còn Maybe có dạng là * -> *. Vì để có được một giá trị, nó phải là một kiểu cụ thể và vì vậy phải được áp dụng đầy đủ, mỗi giá trị của Frank blah blaah đều có dạng *.
Việc làm cho Frank trở thành thể hiện của Tofu là rất đơn giản. Ta thấy rằng tofu nhận vào một j a (ví dụ Maybe Int) rồi trả về t a j. Vì vậy nếu ta thay thế Frank bằng j, kiểu của kết quả sẽ là Frank Int Maybe.
instance Tofu Frank where
    tofu x = Frank x
ghci> tofu (Just 'a') :: Frank Char Maybe
Frank {frankField = Just 'a'}
ghci> tofu ["HELLO"] :: Frank [Char] []
Frank {frankField = ["HELLO"]}
Không có ích lắm, nhưng ta đã cho thấy sức mạnh của kiểu mới code được. Ta hãy code thêm một kiểu linh tinh khác. Ta có kiểu dữ liệu này:
data Barry t k p = Barry { yabba :: p, dabba :: t k }
Và bây giờ ta muốn nó trở thành thể hiện của Functor. Functor cần kiểu dạng * -> * nhưng dường như Barry không có dạng này. Dạng của Barry là gì? À, ta thấy nó nhận vào ba tham số kiểu, vì vậy nó sẽ là something -> something -> something -> *. An toàn nhất là nói rằng p là kiểu cụ thể và do đó có dạng *. Đối với k, ta giả định là nó có dạng * và suy ra, t có dạng * -> *. Bây giờ hãy thay thế vào chỗ something mà ta đã tạm code ở trên; ta thấy được rằng nó có dạng là (* -> *) -> * -> * -> *. Hãy dùng GHCI để kiểm tra.
ghci> :k Barry
Barry :: (* -> *) -> * -> * -> *
À, ta đã nhận định đúng. Thật thỏa mãn. Bây giờ, để khiến kiểu này thuộc Functor ta phải áp dụng từng phần hai tham số kiểu đầu để cho còn lại * -> *. Điều đó có nghĩa rằng chỗ bắt đầu khai báo thể hiện sẽ là: instance Functor (Barry a b) where. Nếu ta coi fmap như thể nó được tạo riêng dành cho Barry, thì nó sẽ có kiểu là fmap :: (a -> b) -> Barry c d a -> Barry c d b, vì ta chỉ thay thế f của Functor bằng Barry c d. Tham số kiểu thứ ba của Barry sẽ phải thay đổi và ta thấy rằng nó thuận tiện như ở nhà.
instance Functor (Barry a b) where
    fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}
Được rồi đấy! Ta vừa mới map f lên trường thứ nhất.
Trong mục này, ta đã xét kĩ về cách hoạt động của tham số kiểu và phần nào đã giải thích về mặt hình thức khái niệm “dạng”, như ta đã hình thức hóa tham số hàm với các khai báo hàm. Tuy nhiên, chúng là hai thứ hoàn toàn khác nhau. Thực tế, khi làm việc với Haskell, bạn chẳng cần bận tâm với kiểu và suy diễn kiểu một cách thủ công như ta đã làm. Thông thường, bạn chỉ cần áp dụng từng phần kiểu dữ liệu của bạn cho * -> * hoặc * khi nó thành thể hiện của một trong các class chuẩn; nhưng biết được nguyên nhân và cách thức hoạt động như vậy là một điều hay. Cũng thú vị khi thấy rằng bản thân kiểu lại có kiểu nhỏ hơn. Một lần nữa, bạn không cần phải hiểu hết toàn bộ nội dung ở đây trước khi tiếp tục; song nếu bạn đã hiểu cơ chế hoạt động của các dạng thì dường như bạn đã nắm vững hệ thống kiểu của Haskell.



*Kết thúc bài 11*

[Haskell #12: Input & Output](https://vutuanhai237.github.io/haskell/2021/03/23/haskell-12.html)

<p style="text-align: right">Tác giả</p>

<p style="text-align: right;">
Vũ Tuấn Hải - Monadotory
</p>