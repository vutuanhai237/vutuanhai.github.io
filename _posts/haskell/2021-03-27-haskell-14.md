---
layout: post
title: "Haskell #14: Applicative"
categories: haskell
link: https://vutuanhai237.github.io/haskell/2021/03/27/haskell-14.html
---

[Haskell #13: Dạng](https://vutuanhai237.github.io/haskell/2021/03/25/haskell-11.html)

### **Applicative**

Ở bài này, ta sẽ làm quen với khái niệm Applicative, vốn là Functor nhưng có thêm một số quy tắc và hàm. Trong Haskell chúng được biểu diễn bằng typeclass Applicative, thuộc module Control.Applicative.

Trong Haskell, hàm được curry theo mặc định; nghĩa là hàm nhận nhiều tham số sẽ chỉ nhận một tham số rồi trả lại một hàm nhận tham số tiếp theo, và cứ như vậy. Nếu một hàm có kiểu `a -> b -> c`, ta thường nói rằng nó nhận hai tham số rồi trả lại một giá trị c nhưng thực ra nó nhận `a` rồi trả lại một hàm `b -> c`. Điều này lý giải tại sao ta có thể gọi hàm theo kiểu là f x y hoặc là (f x) y. Cơ chế này cho phép ta áp dụng từng phần để tạo ra các hàm có thể truyền vào hàm khác.

Cho đến giờ, khi ta ánh xạ hàm lên hàm, ta thường ánh xạ hàm chỉ nhận một tham số. Nhưng trường hợp phức tạp như hàm nhận nhiều hơn hai tham số sẽ tương đối phức tạp. Ví dụ: `fmap (*) (Just 3)` sẽ cho kết quả là `Just ((*) 3)` hay (`Just (* 3)`). Ta nhận được một hàm gói trong Just!
```
ghci> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
ghci> :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -> Ordering)
ghci> :t fmap compare "A LIST OF CHARS"
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
```
Nếu ta ánh xạ compare (kiểu `(Ord a) => a -> a -> Ordering`) lên List Char thì sẽ nhận được List hàm có kiểu `Char -> Ordering`, vì hàm compare được áp dụng từng phần với Char trong List.

Như vậy, ánh xạ hàm $f$ (nhiều tham số) lên Functor $F$ sẽ thu Functor $F'$ chứa hàm. Điều này có một số tác dụng, như ta có thể ánh xạ các hàm có khả năng nhận $f$ làm tham số lên $F'$.
```
ghci> let a = fmap (*) [1,2,3,4]
ghci> :t a
a :: [Integer -> Integer]
ghci> fmap (\f -> f 9) a
[9,18,27,36]
```
Một trường hợp khác, ta có Functor `Just (* 3)` và Functor `Just 5`, đồng thời muốn lấy hàm `(* 3)` ra `Just (* 3)` để ánh xạ nó lên `Just 5`? Với các Functor thông thường, ta không thể làm được, vì Functor chỉ định nghĩa fmap là cách ánh xạ hàm lên Functor. Ngay cả khi ánh xạ `\f -> f 9` lên Functor có chứa hàm thì ta vẫn chỉ ánh xạ một hàm bình thường. Ta không thể ánh xạ hàm nằm trong Functor lên một Functor khác, nếu sử dụng pattern matching thì vẫn có thể giải quyết được, nhưng phương pháp tổng quát và trừu tượng vẫn hay hơn.

### **Applicative**

Nằm trong module Control.Applicative, nó định nghĩa hai hàm `pure` và `<*>`:
```
class (Functor f) => Applicative f where
	pure :: a -> f a
	(<*>) :: f (a -> b) -> f a -> f b
```
Trước hết, một Applicative cũng chính là một Functor, ta có thể dùng fmap lên nó.

Phương thức thứ nhất được định nghĩa có tên là pure, pure nhận giá trị kiểu bất kì rồi trả về Functor chứa giá trị đó bên trong. 
Một cách hay hơn khi nghĩ về pure là nó nhận một giá trị rồi đưa vào một ngữ cảnh nào đó - một ngữ cảnh tối thiểu mà vẫn cho ra giá trị đó.

Hàm <*> có kiểu gần tương đương với `fmap :: (a -> b) -> f a -> f b`, là một phiên bản rắc rối hơn. Nếu như fmap nhận một hàm và một Functor và trả về Functor, thì <*> nhận một Functor có chứa hàm cùng một Functor khác rồi kết xuất hàm đó ra khỏi Functor đầu tiên, sau đó ánh xạ hàm lên Functor thứ hai.

Hãy nhìn vào đoạn mã tạo lập thực thể Applicative của Maybe.
instance Applicative Maybe where
	pure = Just
	Nothing <*> _ = Nothing
	(Just f) <*> something = fmap f something
Một lần nữa, từ định nghĩa lớp ta thấy được rằng f đóng vai trò của Functor áp dụng cần phải nhận tham số là một kiểu cụ thể, vì vậy ta viết instance Applicative Maybe where thay vì instance Applicative (Maybe a) where.
Trước hết, pure. Trước đây ta đã nói rằng kiểu dữ liệu này được thiết kế để nhận vào thứ gì đó rồi đựng nó trong một Functor áp dụng. Ta viết pure = Just, vì các constructors giá trị như Just là các hàm thông thường. Ta cũng đã có thể viết là pure x = Just x.
Tiếp theo, ta có định nghĩa cho <*>. Ta không thể kết xuất một hàm từ Nothing, vì nó không chứa hàm nào. Vì vậy ta nói rằng nếu ta cố thử kết xuất một hàm từ Nothing, kết quả sẽ là Nothing. Nếu bạn nhìn vào lời định nghĩa lớp cho Applicative, bạn sẽ thấy rằng có một ràng buộc lớp Functor, có nghĩa là ta có thể giả sử rằng cả hai tham số của <*> đều là Functor. Nếu tham số thứ nhất không phải là Nothing, mà là một Just với một hàm nào đó bên trong, thì ta nói rằng khi đó ta muốn ánh xạ hàm này lên tham số thứ hai. Việc này cũng đảm nhiệm luôn cả trường hợp mà tham số thứ hai là Nothing, vì việc fmap với bất kì hàm nào lên Nothing sẽ trả lại Nothing.
Như vậy đối với Maybe, <*> kết xuất hàm từ giá trị bên trái nếu nó là Just rồi ánh xạ hàm này lên giá trị bên phải. Nếu bất kì tham số nào là Nothing, thì kết quả sẽ là Nothing.
Hay thật. Ta hãy nhanh chóng thử xem sao.
ghci> Just (+3) <*> Just 9
Just 12
ghci> pure (+3) <*> Just 10
Just 13
ghci> pure (+3) <*> Just 9
Just 12
ghci> Just (++"hahah") <*> Nothing
Nothing
ghci> Nothing <*> Just "woot"
Nothing
Ta thấy rằng việc viết pure (+3) và Just (+3) giống nhau như thế nào trong trường hợp này. Hãy dùng pure nếu bạn đang làm việc với các giá trị Maybe trong một ngữ cảnh áp dụng (nghĩa là dùng chúng với <*>), còn nếu không thì gắn bó với Just. Bốn dòng nhập vào đầu tiên cho thấy hàm được kết xuất rồi ánh xạ như thế nào; nhưng trong trường hợp này ta có thực hiện mục đích bằng việc chỉ cần ánh xạ các hàm chưa được bao bọc lên các Functor. Dòng cuối cùng rất thú vị: ta cố gắng kết xuất một hàm từ Nothing rồi ánh xạ nó lên một thứ nào đó, và dĩ nhiên việc làm này sẽ cho kết quả là Nothing.
Với các Functor thông thường, bạn có thể chỉ cần ánh xạ hàm lên một Functor và rồi bạn không thể lấy được giá trị ra bằng bất kỳ cách thông thường nào, ngay cả khi kết quả là một hàm áp dụng từng phần. Functor áp dụng thì khác, nó cho phép bạn thao tác trên nhiều Functor chỉ bằng một hàm duy nhất. Hãy thử chạy mã lệnh sau để kiểm tra:
ghci> pure (+) <*> Just 3 <*> Just 5
Just 8
ghci> pure (+) <*> Just 3 <*> Nothing
Nothing
ghci> pure (+) <*> Nothing <*> Just 5
Nothing
Điều gì đang xảy ra ở đây? Hãy xem xét theo từng bước. <*> có tính kết hợp trái, nghĩa là pure (+) <*> Just 3 <*> Just 5 cũng như (pure (+) <*> Just 3) <*> Just 5. Đầu tiên, hàm + được đặt trong một Functor, trong trường hợp này là một giá trị Maybe có chứa hàm. Vì vậy đầu tiên, ta có pure (+), vốn là Just (+). Tiếp theo, Just (+) <*> Just 3 xảy ra. Kết quả của điều này là Just (3+). Đó là vì áp dụng hàm từng phần. Việc chỉ áp dụng 3 cho hàm + sẽ dẫn đến một hàm nhận vào một tham số và cộng 3 vào cho nó. Sau cùng, Just (3+) <*> Just 5 được thực hiện, và cho kết quả là Just 8.
Tuyệt đấy chứ nhỉ?! Các Functor áp dụng và phong cách áp dụng từng phần trong cách viết pure f <*> x <*> y <*> ... cho phép ta lấy một hàm vốn trông đợi những tham số mà không nhất thiết phải được bọc trong các Functor rồi dùng hàm đó để thao tác trên nhiều giá trị thuộc ngữ cảnh Functor. Hàm này có thể nhận bao nhiêu tham số tùy ý, vì nó luôn được áp dụng từng phần theo từng bước một giữa các lần xuất hiện của <*>.
Điều này còn trở nên tiện lợi và rõ ràng hơn nữa nếu ta xét thấy pure f <*> x bằng với fmap f x. Đây là một trong các định luật áp dụng. Sau này ta sẽ xem xét kỹ hơn, nhưng tạm thời bây giờ ta có thể nhận thấy bằng trực giác. Hãy nghĩ xem, đẳng thức nói trên có lý chứ. Như ta đã nói từ trước, pure đặt một giá trị vào trong một ngữ cảnh mặc định. Nếu ta chỉ đặt một hàm vào trong một ngữ cảnh mặc định rồi kết xuất và áp dụng nó cho một giá trị bên trong một Functor áp dụng khác, thì ta đã làm việc giống như là ánh xạ hàm đó lên Functor áp dụng nêu trên. Thay vì viết pure f <*> x <*> y <*> ..., ta có thể viết fmap f x <*> y <*> .... Đó là lý do tại sao Control.Applicative xuất khẩu một hàm có tên <$>, vốn chỉ là toán tử trung tố fmap. Sau đây là cách định nghĩa nó:
(<$>) :: (Functor f) => (a -> b) -> f a -> f b
f <$> x = fmap f x
Yo! Lưu ý vắn tắt: các biến kiểu thì không phụ thuộc vào tên tham số hoặc các tên giá trị khác. Cái f trong lời khai báo hàm trên đây là một biến kiểu với ràng buộc về lớp, phát biểu rằng bất kì constructor kiểu nào thay thế f phải nằm trong lớp Functor. Còn f trong phần thân hàm kí hiệu cho một hàm mà ta ánh xạ lên x. Việc ta dùng f để biểu diễn cho cả hai cái trên không có nghĩa là chúng biểu thị cho cùng một thứ.
Bằng cách dùng <$>, phong cách áp dụng đã phát huy tác dụng, vì bây giờ nếu ta muốn áp dụng một hàm f đối với ba Functor áp dụng, thì ta có thể viết f <$> x <*> y <*> z. Nếu các tham số không phải là Functor áp dụng mà là giá trị bình thường, thì ta đã viết là f x y z.
Hãy xem xét kỹ hơn cách hoạt động của mã lệnh này. Ta có một giá trị Just "johntra" và một giá trị Just "volta" và muốn kết nối chúng thành một String bên trong một Functor Maybe. Ta làm như sau:
ghci> (++) <$> Just "johntra" <*> Just "volta"
Just "johntravolta"
Trước khi thấy được tại sao ta có được kết quả này, hãy so sánh dòng lệnh trên với:
ghci> (++) "johntra" "volta"
"johntravolta"
Tuyệt! Để dùng một hàm thông thường đối với các Functor áp dụng, ta chỉ cần điểm thêm <$> và <*> lên hàm đó và rồi nó sẽ hoạt động với các Functor áp dụng rồi trả lại một Functor áp dụng. Tuyệt đấy nhỉ?
Dù sao, khi ta viết (++) <$> Just "johntra" <*> Just "volta", thì trước hết (++), vốn có kiểu (++) :: [a] -> [a] -> [a] sẽ được ánh xạ lên Just "johntra", kết quả cho ra một giá trị cũng giống như Just ("johntra"++) và có kiểu là Maybe ([Char] -> [Char]). Lưu ý bằng cách nào mà tham số thứ nhất của (++) đã bị “tiêu thụ” và các a đã biến thành các Char. Và bây giờ Just ("johntra"++) <*> Just "volta" xảy ra, nó lấy hàm ra khỏi Just rồi ánh xạ nó lên Just "volta", cho kết quả là Just "johntravolta". Nếu bất kì một trong hai giá trị này là Nothing, thì kết quả sẽ là Nothing.
Cho đến giờ, ta mới chỉ dùng Maybe trong các ví dụ và bạn có thể nghĩ rằng các Functor áp dụng đều hướng về Maybe. Nhưng còn hàng tá những thực thể khác cũng trong lớp Applicative, vì vậy ta hãy làm quen với chúng!
Danh sách (thực ra là constructor kiểu danh sách, []) là Functor áp dụng. Ngạc nhiên làm sao! Và sau đây là [] trong vai trò thực thể của Applicative:
instance Applicative [] where
	pure x = [x]
	fs <*> xs = [f x | f <- fs, x <- xs]
Trước đây, ta đã nói rằng pure nhận một giá trị và đặt nó vào trong một ngữ cảnh mặc định. Nói cách khác, một ngữ cảnh tối thiểu mà vẫn trả lại được giá trị như vậy. Ngữ cảnh tối thiểu, trong trường hợp với danh sách, thì là danh sách rỗng, [], nhưng danh sách rỗng biểu thị một sự thiếu vắng giá trị, vì vậy nó không thể tự nắm giữ một giá trị mà ta đã dùng pure lên đó. Điều này lý giải tại sao pure nhận một giá trị rồi đặt nó vào trong danh sách một phần tử. Tương tự, ngữ cảnh tối thiểu cho Functor áp dụng Maybe sẽ là Nothing, nhưng nó biểu thị sự khuyết thiếu của giá trị chứ không phải có giá trị, nên pure được tạo lập dưới dạng Just trong phần tạo lập thực thể cho Maybe.
ghci> pure "Hey" :: [String]
["Hey"]
ghci> pure "Hey" :: Maybe String
Just "Hey"
Thế còn về <*>? Nếu ta nhìn vào kiểu mà <*> sẽ nhận nếu nó chỉ hạn chế trong phạm vi danh sách, thì ta có (<*>) :: [a -> b] -> [a] -> [b]. Nó được thiết lập bởi dạng gộp danh sách. <*> bằng cách nào đó đã kết xuất hàm khỏi tham số bên trái của nó rồi ánh xạ lên tham số bên phải. Nhưng vấn đề ở đây là danh sách bên trái có thể không chứa hàm nào, một hàm, hoặc nhiều hàm. Danh sách bên phải cũng có thể chứa ít nhiều hàm khác nhau. Điều này lý giải tại sao ta dùng một dạng gộp danh sách để rút các thứ từ cả hai danh sách. Ta áp dụng từng hàm có trong danh sách bên trái cho từng giá trị ở danh sách bên phải. Danh sách thu được sẽ có đủ mọi tổ hợp giữa việc áp dụng hàm trong danh sách bên trái với giá trị trong danh sách bên phải.
ghci> [(*0),(+100),(^2)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
Danh sách bên trái có ba hàm và danh sách bên phải có ba giá trị, vì vậy danh sách kết quả sẽ có 9 phần tử. Mỗi hàm trong danh sách bên trái sẽ được áp dụng cho một phần tử ở bên phải. Nếu ta có một danh sách các hàm nhận vào hai tham số, thì ta có thể áp dụng các hàm đó cho các phần tử giữa hai danh sách.
ghci> [(+),(*)] <*> [1,2] <*> [3,4]
[4,5,5,6,3,4,6,8]
Vì <*> có tính kết hợp trái, nên [(+),(*)] <*> [1,2] sẽ xảy ra trước, kết quả là có một danh sách [(1+),(2+),(1*),(2*)], vì mỗi hàm bên trái được áp dụng cho một giá trị bên phải. Sau đó, [(1+),(2+),(1*),(2*)] <*> [3,4] xảy ra, và tạo nên kết quả cuối cùng.
Viết mã lệnh theo phong cách áp dụng đối với danh sách thật là thú vị! Hãy xem này:
ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
Một lần nữa, bạn thấy cách mà ta đã dùng một hàm thông thường nhận vào hai chuỗi đứng giữa hai Functor áp dụng cho chuỗi chỉ bằng cách chèn thêm các toán tử áp dụng phù hợp.
Bạn có thể coi danh sách như những đại lượng (hay đại lượng tính toán) không tất định. Một giá trị như 100 hoặc "what" có thể được coi là một đại lượng tất định nếu như nó chỉ có một kết quả, còn một danh sách như [1,2,3] có thể được coi là một đại lượng không thể tự quyết định được kết quả mong muốn, vì vậy nó biểu diễn cho ta thấy mọi kết quả có thể. Vì vậy, chẳng hạn khi bạn viết (+) <$> [1,2,3] <*> [4,5,6], thì bạn có thể coi nó như là cộng hai đại lượng không tất định bằng +, chỉ là để tạo ra một đại lượng không tất định khác mà thậm chí còn ít khả năng quyết định kết quả hơn nữa.
Việc dùng phong cách áp dụng đối với danh sách thường là cách làm thay thế tốt cho dạng gộp danh sách. Ở Chương 2, khi muốn biết tất cả những tích số giữa các phần tử của [2,5,10] và [8,10,11], ta đã viết:
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]  
[16,20,22,40,50,55,80,100,110]
Đơn giản là ta đã rút các phần tử từ hai danh sách này rồi áp dụng một hàm giữa hai phần tử trong tổ hợp đó. Việc này cũng có thể được làm theo phong cách áp dụng:
ghci> (*) <$> [2,5,10] <*> [8,10,11]
[16,20,22,40,50,55,80,100,110]
Như thế này đối với tôi có vẻ rõ ràng hơn, vì sẽ dễ thấy hơn nếu ta chỉ gọi * giữa hai đại lượng không tất định. Nếu ta muốn tất cả những tích số lớn hơn 50 giữa hai phần tử của hai danh sách, thì ta chỉ cần viết:
ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
[55,80,100,110]
Thật dễ thấy rằng pure f <*> xs bằng fmap f xs đối với trường hợp các danh sách. pure f chỉ đơn giản là [f] còn [f] <*> xs sẽ áp dụng từng hàm ở danh sách bến trái cho từng giá trị thuộc danh sách bên phải; nhưng vì chỉ có một hàm trong danh sách bên trái, nên lệnh này sẽ giống như phép ánh xạ.
Một thực thể khác của lớp Applicative mà ta đã gặp là IO. Sau đây là cách tạo lập thực thể này:
instance Applicative IO where
	pure = return
	a <*> b = do
    	f <- a
    	x <- b
    	return (f x)
Vì pure dành trọn cho việc đặt một giá trị trong một ngữ cảnh tối thiểu mà còn giữ được kết quả là giá trị đó; nên việc pure chỉ là return là hoàn toàn hợp lý, vì return thực hiện chính điều đó; nó tạo ra một thao tác I/O không làm việc gì cả, mà chỉ cho kết quả là một giá trị nào đó, nhưng nó không làm bất kì thao tác I/O nào như in ra màn hình hoặc đọc vào từ tập tin.
Nếu <*> là để dành riêng cho IO thì nó sẽ có kiểu là (<*>) :: IO (a -> b) -> IO a -> IO b. Nó sẽ nhận một thao tác I/O nhằm cho ra kết quả là một hàm và một thao tác I/O khác và tạo ra một thao tác I/O mới sao cho khi được thực hiện, thì trước hết là thực hiện thao tác I/O đầu tiên để thu được hàm rồi thực hiện thao tác thứ hai để lấy giá trị, sau đó trả lại kết quả là giá trị tìm được khi áp dụng hàm cho giá trị. Ở đây ta dùng cú pháp do để tạo lập. Hãy nhớ rằng, cú pháp do nhận vào nhiều thao tác I/O rồi dính chúng lại với nhau làm một, hệt như ta đã làm ở đây.
Với Maybe và [], ta có thể hình dung <*> đơn giản như là kết xuất một hàm từ tham số bên trái rồi áp dụng hàm này vào tham số bên phải. Với IO, việc kết xuất vẫn còn đó, nhưng bây giờ ta cũng có khái niệm về xâu chuỗi, vì ta đang lấy hai thao tác I/O và đang xâu chuỗi, hay dính chúng, làm một. Ta phải kết xuất hàm từ thao tác I/O thứ nhất, nhưng để kết xuất được kết quả từ một thao tác I/O, thì nó phải được thực hiện.
Xét đoạn mã lệnh sau:
myAction :: IO String
myAction = do
	a <- getLine
	b <- getLine
	return $ a ++ b
Đây là thao tác I/O mà sẽ nhắc người dùng nhập vào hai dòng chữ và cho ra kết quả là hai dòng được nối lại làm một. Ta thực hiện bằng cách kết dính hai thao tác I/O là getLine và một lệnh return, vì ta muốn thao tác I/O mới được kết dính có chứa kết quả của a ++ b. Một cách viết khác sẽ là theo phong cách áp dụng.
myAction :: IO String
myAction = (++) <$> getLine <*> getLine
Điều mà ta vừa làm là tạo một thao tác I/O để áp dụng một hàm với các kết quả của hai thao tác I/O khác, và đây cũng là thứ như vậy. Hãy nhớ rằng, getLine là một thao tác I/O với kiểu getLine :: IO String. Khi ta dùng <*> giữa hai Functor áp dụng hiện có, thì kết quả cũng là một Functor áp dụng, vì thế tất cả những việc làm trên đều có nghĩa.
Liên hệ với ví dụ cái hộp, ta có thể hình dung getLine như một cái hộp mà sẽ chạy ra môi trường bên ngoài để thu lượm một chuỗi ký tự. Việc viết (++) <$> getLine <*> getLine sẽ tạo nên một cái hộp mới lớn hơn để phân công hai cái hộp đó ra ngoài thu lượm hai dòng chữ từ cửa sổ lệnh, rồi sau đó trình bày kết quả là hai dòng chữ được nối làm một.
Kiểu của biểu thức (++) <$> getLine <*> getLine là IO String, có nghĩa rằng biểu thức này là một thao tác I/O bình thường như bất kỳ thao tác I/O nào khác, mà cũng chứa trong nó một giá trị kết quả, như những thao tác I/O khác. Điều này lý giải tại sao ta có thể viết những lệnh như:
main = do
	a <- (++) <$> getLine <*> getLine
	putStrLn $ "The two lines concatenated turn out to be: " ++ a
Nếu bạn đã rơi vào trường hợp phải gắn những thao tác I/O nào đó với những cái tên rồi gọi một hàm nào đó lên chúng, sau đó biểu diễn kết quả bằng return, thì hãy tính đến việc viết theo phong cách áp dụng vì có lẽ nó ngắn gọn hơn.
Một thực thể khác của Applicative là (->) r, các hàm. Dù hiếm khi được dùng theo phong cách áp dụng ngoài mục đích viết mã lệnh càng ngắn càng tốt, nhưng chúng vẫn thú vị như các thực thể áp dụng khác; vì vậy ta hãy cùng xem cách tạo lập thực thể hàm này.
Nếu bạn bị rối trí về ý nghĩa của (->) r, hãy đọc lại mục trước trong đó chúng tôi đã giải thích (->) r là một Functor như thế nào.
instance Applicative ((->) r) where
	pure x = (\_ -> x)
	f <*> g = \x -> f x (g x)
Khi ta gói một giá trị vào bên trong một Functor áp dụng bằng pure, thì kết quả mà Functor áp dụng cho ra sẽ luôn luôn là giá trị đó. Một ngữ cảnh mặc định nhỏ nhất mà vẫn cho ra kết quả là giá trị đó. Điều này lý giải tại sao mà trong phần tạo lập thực thể hàm, pure nhận một giá trị rồi tạo ra một hàm phớt lờ đi các tham số được cấp và luôn trả lại giá trị đó. Nếu ta nhìn vào kiểu của pure, dành riêng cho thực thể (->) r, thì nó là pure :: a -> (r -> a).
ghci> (pure 3) "blah"
3
Vì tính chất curry mà việc áp dụng hàm luôn có tính kết hợp trái, vì vậy ta có thể bỏ qua cặp ngoặc tròn.
ghci> pure 3 "blah"
3
Cách tạo lập hàm cho <*> trông hơi bí hiểm, vì vậy tốt nhất là ta chỉ nhìn vào cách dùng các hàm với vai trò Functor áp dụng theo phong cách áp dụng.
ghci> :t (+) <$> (+3) <*> (*100)
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a
ghci> (+) <$> (+3) <*> (*100) $ 5
508
Việc gọi <*> với hai Functor áp dụng sẽ cho kết quả là một Functor áp dụng, vì vậy nếu ta dùng nó với hai hàm thì ta sẽ thu lại được một hàm. Như vậy điều gì đang diễn ra ở đây? Khi viết (+) <$> (+3) <*> (*100), ta đang lập nên một hàm sẽ dùng + đối với các kết quả của (+3) và (*100) rồi trả lại kết quả đó. Lấy một ví dụ cụ thể, khi viết (+) <$> (+3) <*> (*100) $ 5, thì ban đầu số 5 được áp dụng vào (+3) và (*100), cho ra 8 và 500. Sau đó, + được gọi với 8 và 500, cho ra kết quả 508.
ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
[8.0,10.0,2.5]
Ở đây cũng vậy. Ta tạo ra một hàm để gọi hàm \x y z -> [x,y,z] cùng với các kết quả cuối cùng từ (+3), (*2) và (/2). Số 5 được đưa vào từng hàm trong số ba hàm này và rồi \x y z -> [x, y, z] được gọi với các kết quả đó.
Bạn có thể hình dung các hàm như những chiếc hộp có chứa kết quả cuối cùng của chúng, vì vậy việc viết k <$> f <*> g tạo ra một hàm mà sẽ gọi k với các kết quả cuối cùng từ f và g. Khi tao viết, chẳng hạn (+) <$> Just 3 <*> Just 5, thì ta đang dùng + với các giá trị mà có thể có hoặc không tồn tại ở đó, và cho kết quả có thể là một giá trị hoặc không là gì cả. Khi viết (+) <$> (+10) <*> (+5), là ta đang dùng + với những giá trị được trả về trong tương lai của (+10) và (+5) đồng thời kết quả sẽ là một thứ gì đó mà sẽ tạo ra một giá trị khi được gọi với một tham số.
Ta không thường dùng các hàm với vai trò Functor ứng dụng, nhưng điều này vẫn rất hay. Chẳng quan trọng lắm nếu bạn không hiểu được cách hoạt động của thực thể (->) r trong Applicative, vì vậy đừng nên thất vọng nếu bây giờ bạn chưa hiểu được. Hãy thử nghịch chơi bằng phong cách áp dụng và với các hàm để hình thành một trực giác dành cho hàm với vai trò Functor áp dụng.
Một thực thể của Applicative mà ta vẫn chưa gặp là ZipList, và nó tần tại ở Control.Applicative.
Hóa ra là còn có những cách khác để biến danh sách trở thành Functor áp dụng. Một cách mà ta đã đề cập đến, theo đó việc gọi <*> với một danh sách các hàm và một danh sách các giá trị sẽ trả lại kết quả là một danh sách có tất cả những tổ hợp có thể của việc áp dụng hàm ở danh sách bên trái lên các giá trị ở danh sách bên phải. Nếu ta viết [(+3),(*2)] <*> [1,2], thì (+3) sẽ được áp dụng cho cả 1 và 2 còn (*2) sẽ được áp dụng cho cả 1 và 2, kết quả là được một danh sách gồm 4 phần tử, [4,5,2,4].
Tuy nhiên, [(+3),(*2)] <*> [1,2] cũng có thể hoạt động theo cách mà hàm thứ nhất trong danh sách bên trái được áp dụng vào giá trị thứ nhất trong danh sách bên phải, hàm thứ hai áp dụng vào giá trị thứ hai, và cứ như vậy. Kết quả sẽ là một danh sách có hai giá trị, [4,4]. Bạn có thể coi nó như là [1 + 3, 2 * 2].
Vì một kiểu dữ liệu không thể có hai thực thể trong cùng một lớp, nên kiểu ZipList a được giới thiệu, nó có một constructor ZipList chỉ gồm một trường, và trường đó là một danh sách. Sau đây là thực thể này:
instance Applicative ZipList where
    	pure x = ZipList (repeat x)
    	ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
<*> thực hiện đúng như điều mà tôi đã nói. Nó áp dụng hàm thứ nhất vào cho giá trị thứ nhất, hàm thứ hai vào giá trị thứ hai, v.v. Điều này được zipWith (\f x -> f x) fs xs đảm nhiệm. Vì cách hoạt động của zipWith mà danh sách kết quả sẽ dài bằng với danh sách ngắn hơn trong số hai danh sách.
Ở đây, pure cũng rất thú vị. Nó nhận một giá trị rồi đặt nó vào trong một danh sách có giá trị đó lặp lại vô tận. pure "haha" sẽ cho kết quả ZipList (["haha","haha","haha".... Điều này có thể gây đôi chút nhầm lẫn vì ta đã nói rằng pure cần đặt một giá trị vào trong ngữ cảnh tối thiểu sao cho vẫn có thể cho ra giá trị. Và bạn có thể nghĩa rằng một danh sách vô tận thì không thể là “tối thiểu” được. Nhưng với những danh sách đan cài (zip) thì hoàn toàn có nghĩa, bởi nó phải tạo ra một giá trị tại mọi vị trí. Như vậy cũng thỏa mãn định luật phát biểu rằng pure f <*> xs phải bằng fmap f xs. Nếu pure 3 chỉ trả lại ZipList [3], thì pure (*2) <*> ZipList [1,5,10] sẽ cho kết quả là ZipList [2], vì danh sách kết quả gồm hai danh sách đan cài thì chỉ dài bằng danh sách ngắn hơn. Nếu ta đan cài một danh sách hữu hạn với một danh sách vô hạn, thì chiều dài của danh sách kết quả sẽ bằng của danh sách hữu hạn.
Như vậy danh sách đan cài hoạt động thế nào theo phong cách áp dụng? Hãy xem nhé. Ồ, kiểu dữ liệu ZipList a không có một thực thể Show, vì vậy ta phải dùng hàm getZipList để kết xuất một danh sách nguyên gốc ra khỏi một danh sách đan cài.
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
[101,102,103]
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
[101,102,103]
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
[5,3,3,4]
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
[('d','c','r'),('o','a','a'),('g','t','t')]
Hàm (,,) cũng giống như \x y z -> (x,y,z). Đồng thời, hàm (,) cũng giống như \x y -> (x,y).
Bên cạnh zipWith, thư viện chuẩn còn có các hàm như zipWith3, zipWith4, cứ như vậy lên đến số 7. zipWith nhận một hàm mà hàm này nhận hai tham số, rồi dùng hàm để đan cài hai danh sách. zipWith3 nhận một hàm mà hàm này nhận ba tham số, rồi dùng hàm để đan cài ba danh sách, và cứ như vậy. Bằng cách dùng danh sách đan cài với phong cách áp dụng, ta sẽ không cần có một hàm zip (đan cài) riêng cho mỗi trường hợp một số cụ thể các danh sách cần đan cài. Ta chỉ việc dùng phong cách áp dụng để đan cài lại một số lượng tùy ý các danh sách chỉ bằng một hàm duy nhất, điều này thật tuyệt.
Control.Applicative định nghĩa một hàm có tên liftA2, vốn có kiểu liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c . Nó được định nghĩa như sau:
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = f <$> a <*> b
Không có gì đặc biệt, nó chỉ áp dụng một hàm giữa hai Functor áp dụng, ẩn giấu đi phong cách áp dụng mà ta vừa làm quen. Nguyên nhân khiến ta xem xét hàm này là vì nó cho thấy rõ ràng tại sao các Functor áp dụng lại mạnh hơn nhiều các Functor thông thường. Với Functors thông thường, ta chỉ có thể ánh xạ các hàm lên một Functor. Nhưng với Functor áp dụng, ta có thể áp dụng một hàm giữa nhiều Functor. Cũng thú vị khi thấy kiểu của hàm này là (a -> b -> c) -> (f a -> f b -> f c). Khi ta nhìn vào nó trên khía cạnh này, ta có thể nói rằng liftA2 nhận vào một hàm hai ngôi bình thường và nâng cấp nó thành một hàm hoạt động với hai Functor.
Sau đây là một khái niệm quan trọng: ta có thể lấy hai Functor áp dụng rồi kết hợp chúng thành một Functor áp dụng chứa trong đó kết quả của hai Functor áp dụng này trong một danh sách. Chẳng hạn, ta có Just 3 và Just 4. Hãy giả sử rằng cái thứ hai chứa trong nó một danh sách đơn phần tử, vì thật dễ đạt được điều này:
ghci> fmap (\x -> [x]) (Just 4)
Just [4]
Được rồi, vậy giả dụ như ta có Just 3 và Just [4]. Bằng cách nào ta có được Just [3,4]? Thật đơn giản.
ghci> liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci> (:) <$> Just 3 <*> Just [4]
Just [3,4]
Hãy nhớ rằng, : là một hàm nhận vào một phần tử và một danh sách rồi trả về một danh sách mới có phần tử đó đứng đầu. Bây giờ khi ta đã có Just [3,4], liệu ta có thể kết hợp nó với Just 2 để tạo ra Just [2,3,4]? Dĩ nhiên là được chứ. Dường như ta có thể kết hợp một số lượng bất kỳ các Functor áp dụng vào làm một, trong đó chứa một danh sách tất cả kết quả của những Functor áp dụng ban đầu. Ta hãy thử lập một hàm nhận vào một danh sách các Functor áp dụng rồi trả lại một Functor áp dụng có giá trị kết quả là một danh sách. Ta sẽ gọi hàm này là sequenceA.
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
A, đệ quy! Đầu tiên, ta hãy nhìn vào kiểu dữ liệu. Nó sẽ chuyển đổi một danh sách các Functor áp dụng thành một Functor áp dụng với một danh sách. Từ đó, ta có thể đặt nền móng cho điều kiện biên. Nếu ta muốn chuyển đổi một danh sách rỗng thành một Functor áp dụng với một danh sách các kết quả, thì ta chỉ việc đặt danh sách rỗng vào trong một ngữ cảnh mặc định. Bây giờ thì đến đệ quy. Nếu ta có một danh sách với phần tử đầu và đoạn cuối (hãy nhớ rằng, x là một Functor áp dụng và xs là một danh sách của chúng), thì ta gọi sequenceA đối với phần đuôi danh sách, từ đó sẽ trả lại một Functor áp dụng với một danh sách. Sau đó, ta chỉ việc đặt cái giá trị bên trong của (Functor áp dụng) x trước Functor áp dụng với danh sách nói trên, và thế là xong!
Như vậy, nếu ta viết sequenceA [Just 1, Just 2], thì đó là (:) <$> Just 1 <*> sequenceA [Just 2] . Tức là bằng với (:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA []). A! Ta biết rằng sequenceA [] cuối cùng sẽ là Just [], vì vậy biểu thức này bây giờ là (:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just []), vốn là (:) <$> Just 1 <*> Just [2], hay là Just [1,2]!
Một cách khác để lập sequenceA là dùng một hàm gấp. Hãy nhớ rằng, hầu như bất kì hàm nào mà ta dùng để duyệt qua từng phần tử một danh sách đồng thời tích lũy kết quả, thì đều có thể lập được bằng hàm gấp.
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA = foldr (liftA2 (:)) (pure [])
Ta tiếp cận danh sách từ phía phải và khởi đầu với một giá trị pure []. Sau đó thực hiện liftA2 (:) giữa biến tích lũy và phần tử cuối danh sách, việc này cho kết quả là một Functor áp dụng có một phần tử trong đó. Tiếp theo là liftA2 (:) với phần tử cuối lúc này và biến tích lũy hiện thời và cứ như vậy, đến khi ta chỉ còn lại biến tích lũy, biến này nắm giữ danh sách các kết quả của toàn bộ những Functor áp dụng.
Ta hãy thử lướt qua hàm vừa viết với những Functor áp dụng khác nhau.
ghci> sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci> sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci> sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]
A! Hay đấy. Khi dùng với các giá trị Maybe, hàm sequenceA tạo ra một giá trị Maybe với tất cả những kết quả trong nó dưới dạng danh sách. Nếu một trong các giá trị là Nothing, thì kết quả cũng là Nothing. Điều này hay vì khi bạn có một danh sách các giá trị Maybe và bạn quan tâm đến các giá trị trong đó chỉ khi không có giá trị nào là Nothing.
Khi dùng với các hàm, sequenceA sẽ nhận một danh sách các hàm rồi trả lại một hàm mà hàm này trả lại một danh sách. Trong ví dụ đang xét, ta tạo ra một hàm nhận tham số là một con số rồi áp dụng hàm này cho từng hàm trong danh sách, và trả lại một danh sách các kết quả. sequenceA [(+3),(+2),(+1)] 3 sẽ gọi (+3) với 3, (+2) với 3 và (+1) với 3 rồi biểu thị tất cả những kết quả đó dưới dạng một danh sách.
Việc viết (+) <$> (+3) <*> (*2) sẽ tạo ra một hàm nhận vào một tham số, để cung cấp cho cả (+3) và (*2) rội gọi + đối với cả hai kết quả đó. Cũng theo tinh thần đó, sẽ hoàn toàn hợp lý khi sequenceA [(+3),(*2)] tạo ra một hàm nhận một tham số rồi cung cấp cho toàn bộ các hàm trong danh sách. Thay vì gọi + với các kết quả trong hàm, thì sự kết hợp giữa : và pure [] được dùng để thu gom các kết quả đó trong danh sách, vốn là kết quả của hàm được xét.
Việc dùng sequenceA sẽ rất hay khi ta có một danh sách các hàm và muốn cung cấp cùng một dữ liệu đầu vào cho tất cả những hàm đó rồi xem danh sách các kết quả. Chẳng hạn, ta có một con số và muốn biết xem nó có thỏa mãn tất cả những vị từ trong một danh sách hay không. Một cách thực hiện điều này như sau:
ghci> map (\f -> f 7) [(>4),(<10),odd]
[True,True,True]
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]
True
Hãy nhớ rằng, and nhận một danh sách các giá trị boole rồi trả lại True nếu chúng đều là True. Một cách khác để thu được kết quả tương tự là dùng sequenceA:
ghci> sequenceA [(>4),(<10),odd] 7
[True,True,True]
ghci> and $ sequenceA [(>4),(<10),odd] 7
True
sequenceA [(>4),(<10),odd] tạo ra một hàm nhận một con số rồi cung cấp nó cho tất cả những vị từ trong [(>4),(<10),odd] rồi trả lại một danh sách các giá trị boole. Nó trả lại một danh sách có kiểu (Num a) => [a -> Bool] vào trong một hàm có kiểu (Num a) => a -> [Bool]. Khá là gọn gàng nhỉ?
Vì danh sách có tính đồng nhất, nên dĩ nhiên các hàm trong danh sách phải có cùng kiểu với nhau. Bạn không thể có một danh sách như [ord, (+3)], vì ord nhận một ký tự rồi trả lại một con số, còn (+3) nhận một con số rồi trả lại một con số.
Khi được dùng với [], hàm sequenceA nhận một danh sách chứa các danh sách rồi trả lại một danh sách cũng chứa các danh sách. Hừm, thú vị đấy. Hàm này tạo ra các tất cả các danh sách là tổ hợp có thể từ những phần tử trong từng danh sách ban đầu. Để minh họa, sau đây là mã lệnh thực hiện với sequenceA và dạng gộp danh sách:
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> [[x,y] | x <- [1,2], y <- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
Dường như hơi khó hiểu, nhưng nếu bạn nghịch chơi một lúc thì sẽ thấy được cách làm trên hoạt động ra sao. Chẳng hạn, hãy xét sequenceA [[1,2],[3,4]]. Để thấy được những gì xảy ra, hãy dùng định nghĩa sequenceA (x:xs) = (:) <$> x <*> sequenceA xs của sequenceA và điều kiện biên sequenceA [] = pure []. Bạn không cần phải theo sát cách lượng giá này, nhưng có thể nó sẽ giúp bạn nếu bạn gặp vấn đề trong việc hình dung cách mà sequenceA làm việc với danh sách các danh sách, vì để hiểu được có thể sẽ cần phải vắt óc một lúc.
§  Ta bắt đầu với sequenceA [[1,2],[3,4]]
§  Nó được định giá là (:) <$> [1,2] <*> sequenceA [[3,4]]
§  Tiếp tục định giá biểu thức sequenceA bên trong, ta thu được (:) <$> [1,2] <*> ((:) <$> [3,4] <*> sequenceA [])
§  Ta đã đạt tới điều kiện biên, vì vậy bây giờ ta có (:) <$> [1,2] <*> ((:) <$> [3,4] <*> [[]])
§  Bây giờ ta định giá phần (:) <$> [3,4] <*> [[]], vốn sẽ dùng đến : với từng giá trị có thể trong danh sách bên trái (những giá trị có thể bao gồm 3 và 4) với từng giá trị có thể trong danh sách bên phải (giá trị duy nhất là []), từ đó cho kết quả [3:[], 4:[]], hay là [[3],[4]]. Như vậy bây giờ ta có (:) <$> [1,2] <*> [[3],[4]]
§  Đến đây, : được dùng với từng giá trị có thể ở danh sách bên trái (1 và 2) và từng giá trị của danh sách bên phải ([3] và [4]), từ đó cho kết quả [1:[3], 1:[4], 2:[3], 2:[4]], hay là [[1,3],[1,4],[2,3],[2,4]
Việc viết (+) <$> [1,2] <*> [4,5,6]sẽ cho kết quả là một đại lượng không tất định x + y trong đó x nhận từng giá trị từ [1,2] và y nhận từng giá trị từ [4,5,6]. Ta biểu diễn điều này bằng một danh sách chứa tất cả những kết quả có thể. Tương tự, khi viết sequence [[1,2],[3,4],[5,6],[7,8]], kết quả là một đại lượng không tất định [x,y,z,w], trong đó x nhận từng giá trị từ [1,2], y nhận từng giá trị từ [3,4] và cứ như vậy. Để biểu diễn kết quả của đại lượng không tất định này, ta dùng một danh sách trong đó mỗi phần tử trong danh sách lại là một danh sách có thể xuất hiện. Điều này lý giải tại sao kết quả là một danh sách chứa các danh sách.
Khi dùng với thao tác I/O, sequenceA cũng giống như sequence! Nó nhận vào một danh sách các thao tác I/O rồi trả lại một thao tác I/O để thực hiện từng hành động trong số đó rồi có kết quả là một danh sách những kết quả các thao tác I/O thành phần. Đó là vì để biến một giá trị [IO a] thành một giá trị IO [a], một thao tác I/O để cho danh sách các kết quả khi được thực hiện, thì tất cả những thao tác I/O đó phải được xâu chuỗi sao chó chúng có thể được thực hiện lần lượt khi bắt buộc phải lượng giá. Bạn không thể thu được kết quả của một thao tác I/O mà không thực hiện nó.
ghci> sequenceA [getLine, getLine, getLine]
heyh
ho
woo
["heyh","ho","woo"]
Như các Functor thông thường, Functor áp dụng cũng có một số định luật. Quan trọng nhất là định luật mà ta đã đề cập đến, pure f <*> x = fmap f x phải thỏa mãn. Bạn hãy chứng minh định luật này cho một số Functor áp dụng mà ta đã gặp trong chương; coi như đây là một bài tập. Các định luật khác gồm có:
§  pure id <*> v = v
§  pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
§  pure f <*> pure x = pure (f x)
§  u <*> pure y = pure ($ y) <*> u
Ngay bây giờ, ta sẽ không đi sâu vào chi tiết vì như vậy sẽ phải trình bày quá dài dòng và có thể sẽ nhàm chán, nhưng nếu bạn sẵn sàng đương đầu với thử thách, thì hãy xem kĩ những định luật trên và kiểm tra xem chúng có thỏa mãn với một số các thực thể hay không.
Tóm lại, Functor áp dụng không chỉ thú vị, mà nó còn hữu ích, vì cho phép ta kết hợp các đại lượng khác nhau, như đại lượng I/O, đại lượng không tất định, đại lượng có thể thất bại trong quá trình tính toán, v.v. qua việc dùng phong cách áp dụng. Chỉ bằng cách dùng <$> và <*> ta có thể dùng những hàm thông thường để thao tác một cách đồng đều lên bao nhiêu Functor áp dụng cũng được, đồng thời tận dụng ưu điểm ngữ nghĩa của từng Functor.
 
*Kết thúc bài 13

[Haskell #14: Monad](https://vutuanhai237.github.io/haskell/2021/03/25/haskell-14.html)

<p style="text-align: right">Tác giả</p>

<p style="text-align: right;">
Vũ Tuấn Hải - Monadotory
</p>